<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Market Model — Revenues (2028–2047)</title>
  <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
<style>
  :root{--panel-bg:#e6f0ef;--muted:#666;--card-bg:#fff;--accent:#0b5cff}
  *{box-sizing:border-box}
  body{margin:0;font-family:Inter,Arial,Helvetica,sans-serif;display:flex;height:100vh;color:#111}
  #controls{width:320px;border-right:1px solid #e6e6e6;padding:14px;background:var(--panel-bg);overflow:auto}
  #graphWrap{
    flex:1;
    display:flex;
    flex-direction:column;
    padding:12px;
    background:#e6f0ef; /* new background, same muted color */
  }

/* Generic track baseline */
input[type="range"] {
  width: 100%;
  -webkit-appearance: none;
  appearance: none;
  height: 6px;
  border-radius: 3px;
  border: 1px solid #ddd;
  background: #eee; /* default neutral track */
  background-image: linear-gradient(to right, var(--fill-color, #888) var(--percent,0%), #eee var(--percent,0%));
}

/* Thumb */
input[type="range"]::-webkit-slider-thumb {
  -webkit-appearance: none;
  appearance: none;
  width: 14px;
  height: 14px;
  border-radius: 50%;
  background: var(--fill-color, #888);
  cursor: pointer;
  border: 1px solid #333;
  position: relative;
  z-index: 2;
}

input[type="range"]::-moz-range-thumb {
  width: 14px;
  height: 14px;
  border-radius: 50%;
  background: var(--fill-color, #888);
  cursor: pointer;
  border: 1px solid #333;
}


  .card{background:var(--card-bg);border:1px solid #e9e9e9;border-radius:8px;padding:10px;margin-bottom:12px}
  label{display:block;font-weight:600;margin-bottom:6px;font-size:13px}
  .small{font-size:12px;color:var(--muted)}
  select, input[type="number"]{width:100%;padding:6px;border:1px solid #ddd;border-radius:6px}
  .checks{display:grid;gap:6px}
  .check-row{display:flex;align-items:center;gap:8px;font-size:13px}
  #plot{height:64vh; position: relative;} /* overlay sits inside */
  #arrowOverlay { position:absolute; left:0; top:0; width:100%; height:100%; pointer-events:none; }
  .kpis{display:flex;gap:12px;margin-top:12px}
  .kpi{flex:1;background:var(--card-bg);border:1px solid #e9e9e9;border-radius:8px;padding:10px;text-align:center}
  .kpi .big{font-size:18px;font-weight:700;margin-top:8px}
  .country-card{margin-bottom:8px;padding:8px;border-radius:6px;background:#fff;border:1px solid #f0f0f0;font-size:13px}
  .slider-row { margin-bottom: 12px; }
  .ref { font-size:11px;color:#666;margin-top:8px; line-height:1.35;}

.card > label:first-child, 
.card > h3:first-child {
  font-size: 14px;
  font-weight: 600;
  margin-bottom: 6px;
  color: #222;
  border-bottom: 1px solid #eee;
  padding-bottom: 4px;
}
/* Neutral sliders (erosion, cost rate) */
input[type="range"].neutral {
  --fill-color: #bbb;
  background: linear-gradient(to right, var(--fill-color) var(--percent), #eee var(--percent));
}
.india-pop-card {
  background: #fafafa;
  border: 1px solid #eee;
  padding: 6px;
  border-radius: 6px;
  margin-top: 6px;
}
.india-pop-card label {
  font-size: 12px;
  font-weight: 500;
  margin-bottom: 2px;
  display: block;
}
</style>
</head>
<body>
  <div id="controls">
    <h2>Model parameters</h2>
    
    <div class="card">
        <label>Indications</label>
        <div id="indicationChecks" class="checks"></div>
    </div>

    <div class="card">
      <label>Regions</label>
      <div id="countryChecks" class="checks"></div>
    </div>
    
    <div class="card">
        <label>Peak Market Share (%, by Region)</label>
        <div id="peakYearSlidersContainer"></div>
    </div>

    <div class="card">
      <label for="patentExtensionInput">Patent Exclusivity Extension (+ Years)</label>
      <input id="patentExtensionInput" type="number" min="0" max="10" step="1" value="0" />
      <div class="small" style="margin-top:6px">Applies to all selected regions.</div>
      
      <div style="height:10px"></div>
      <label for="erosionRate">Post-LoE annual erosion (%)</label>
      <input id="erosionRate" type="range" min="0.5" max="5" step="0.1" value="2.5" />
      <div class="small">Compounding decline after LoE: <span id="erosionRateVal">2.5%</span>/yr</div>
    </div>

    <div class="card">
  	<label>Treatment cost (USD, by region)</label>
  	<div id="treatmentCostSliders"></div>
	</div>
    
    <div class="card">
        <label>Cost Parameters</label>
        <label for="variableCostSlider" class="small" style="font-weight:normal;margin-bottom:4px;">Operational Cost Rate (% of Gross Revenue)</label>
        <input id="variableCostSlider" type="range" min="1" max="30" step="0.1" value="5" />
        <div class="small">Current rate: <span id="variableCostVal">5.0%</span>/yr</div>
        <div class="small" style="margin-top:8px;">Note: A flat $30M cost for the Phase II trial is applied in 2028.</div>
    </div>

    <div class="card">
      <h3 style="margin:0 0 8px 0">Base assumptions (read-only)</h3>
<div id="assumptionMethod" class="small" style="margin:6px 0 10px 0;">
  <strong>How we compute “Addressable patients (at peak)”</strong><br>
  For each indication and region: <em>Total cases</em> × <em>Neurosurgery eligibility</em> × <em>Peak Market Share</em> (set with the slider; ramps linearly to peak in 6 years).
  <div style="margin-top:4px;">
    Neurosurgery eligibility used for GBM: <strong>~70%</strong>, BM: <strong>~15%</strong>, OPBT: <strong>~33%</strong>.
  </div>
</div>
      <div id="countryAssumptions"></div>

<!-- New explanatory notes -->
<div id="assumptionNotes" class="small" style="margin-top:8px; line-height:1.45">
  <div><strong>Patient figures</strong>: For each region, the counts shown per indication (<strong>Glioblastoma</strong>, <strong>Brain Metastasis</strong>, <strong>OPBT</strong>) are the incidence values used by the model (same years window and neurosurgery filters). If data is insufficient in a specific country or region, assumptions are based on other regions' data.</div>

  <div style="margin-top:8px;"><strong>Brain Metastasis eligibility & addressable pool</strong>: Literature places neurosurgery eligibility at <strong>~15%</strong> of all BM cases. In the model the <em>addressable population</em> is defined as <strong>Total BM × (15%)</strong>. Use the <strong>Peak Market Share (%)</strong> slider(s) to set your target capture of this addressable pool by region.</div>

  <div style="margin-top:8px;"><strong>Adoption ramp</strong>: From launch, market share increases linearly to the selected slider value over <strong>6 years</strong>, then remains at that level until loss of exclusivity (LoE). After LoE, revenues erode at the rate set by the <strong>Post-LoE annual erosion</strong> slider.</div>

  <div style="margin-top:8px;"><strong>Clinical costs</strong>: A flat <strong>$30M</strong> Phase II cost is applied in <strong>2028</strong>. Each additional indication incurs a <strong>$25M</strong> bridging study cost, applied at <strong>Launch (2030)</strong> for the first add-on, and then at <strong>+3 years</strong> for subsequent add-ons.</div>

  <div style="margin-top:8px;"><strong>Operational cost slider</strong>: Covers <strong>Marketing</strong>, <strong>CMC</strong>, <strong>COGs</strong>, and <strong>FTE</strong> (expressed as % of gross revenue).</div>

  <div style="margin-top:10px"><strong>Sources</strong>:</div>
  <div class="ref">
    https://academic.oup.com/neuro-oncology/article/23/9/1447/6256866<br>
    https://www.ncbi.nlm.nih.gov/books/NBK470246/<br>
    https://www.nature.com/articles/s43856-024-00445-7<br>
    https://www.nejm.org/doi/full/10.1056/NEJM199002223220802<br>
    https://pmc.ncbi.nlm.nih.gov/articles/PMC9533228<br>
    https://statistik.incanet.se/CNS/<br>
    https://www.nature.com/articles/s41598-024-79170-z<br>
    https://www.worldometers.info/world-population/<br>
    https://glioblastomafoundation.org/news/glioblastoma-multiforme<br>
    https://academic.oup.com/nop/article/6/1/37/5001149
    https://jamanetwork.com/journals/jamanetworkopen/fullarticle/2837792<br>
    https://www.cns.org/guidelines/treatment-adults-metastatic-brain-tumors/practice-guideline-on-role-of-surgery-in-managemen<br>
    https://ascopubs.org/doi/10.1200/JCO.21.02314<br>
    https://pmc.ncbi.nlm.nih.gov/articles/PMC3877503/<br>
    https://journals.lww.com/indianjcancer/fulltext/2023/60030/incidence_and_clinical_profile_of_brain_metastasis.8.aspx
  </div>
</div>

    </div>
  </div>

  <div id="graphWrap">
    <div id="plot">
      <svg id="arrowOverlay" xmlns="http://www.w3.org/2000/svg"></svg>
    </div>

    <div class="kpis">
      <div class="kpi">
        <div class="small">Peak Revenue (USD)</div>
        <div class="big" id="peakSalesVal">$0</div>
        <div class="small" id="peakSalesYear">Year: —</div>
      </div>

      <div class="kpi">
        <div class="small">Cumulative Revenue</div>
        <div style="display:flex;gap:8px;align-items:center;justify-content:center;margin-top:6px">
          <select id="cumStart"></select><div class="small">→</div><select id="cumEnd"></select>
        </div>
        <div class="big" id="cumSalesVal">$0</div>
        <div class="small" id="cumSpan">Span: —</div>
      </div>
    </div>
  </div>

  <script>
  // -------------------------------
  // Model years & anchors
  // -------------------------------
  const years = Array.from({length: 20}, (_, i) => 2028 + i); // 2028..2047
  const launchYear = 2030;
  const launchIdx = Math.max(0, years.indexOf(launchYear));
  const baseTreatmentCosts = {
  "EU4+UK": 70000,
  "US": 70000,
  "Japan": 70000,
  "India": 25000
};

  // -------------------------------
  // Epidemiology data 
  // -------------------------------
  // Flat yearly incidence arrays using the exact numbers you provided
// -------------------------------
// Epidemiology assumptions
// -------------------------------

// Populations (fixed except India)
const basePopulation = {
  "EU4+UK": 325_000_000,
  "US": 340_000_000,
  "Japan": 125_000_000,
  "India": 300_000_000
};
let indiaPopulation = basePopulation["India"]; // editable

// Incidence per 100k (yearly)
const incidencePer100k = {
  "Glioblastoma": 3.0,
  "Brain Metastasis": 53.7,
  "OPBT": 3.0
};

// Neurosurgery eligibility (% of cases)
const neurosurgeryPct = {
  "Glioblastoma": { "EU4+UK": 0.70, "US": 0.73, "Japan": 0.70, "India": 0.50 },
  "Brain Metastasis": { "EU4+UK": 0.08, "US": 0.08, "Japan": 0.07, "India": 0.07 },
  "OPBT": { "EU4+UK": 0.33, "US": 0.33, "Japan": 0.33, "India": 0.33 }
};


  const indicationOrder = ["Glioblastoma", "Brain Metastasis", "OPBT"];
  const groupOrder = ["EU4+UK", "US", "Japan", "India"];
  const groupColors = { "EU4+UK": "#2f6df6", "US": "#00b37e", "Japan": "#f59e0b", "India": "#fc0000" };

// Fixed indication colors per region (ensures consistent shades across selections)
const indicationColors = {
  "Glioblastoma": {
    "EU4+UK": "#2f6df6",
    "US": "#00b37e",
    "Japan": "#f59e0b",
    "India": "#fc0000"
  },
  "Brain Metastasis": {
    "EU4+UK": "#6f92f8",
    "US": "#33c399",
    "Japan": "#f7b733",
    "India": "#ff3333"
  },
  "OPBT": {
    "EU4+UK": "#a5bdfb",
    "US": "#66d9b2",
    "Japan": "#f9cd66",
    "India": "#ff6666"
  }
};

  // -------------------------------
  // Parameters & state
  // -------------------------------
  const baseLoeYears = { "EU4+UK": 2040, "US": 2037, "Japan": 2040, "India": 2040 };
  let peakShareByGroup = { "EU4+UK": 30, "US": 30, "Japan": 30, "India": 30 }; // % target share
  let currentTotalNetRevenues = [];
let currentTreatmentCosts = { ...baseTreatmentCosts };

// -------------------------------
// India population scaling (immutable baselines)
// -------------------------------

function setIndiaPopulation(newPop) {
  indiaPopulation = +newPop || basePopulation["India"];
}

  const additionalDelayYears = 3;   // revenue starts after delay from cost-start
  const additionalRampYears = 4;
  const additionalStartCostValue = 25000000; // $25M per extra indication
  const startupCostValue = 30000000; // $30M Phase II cost applied in 2028

  // Selection order (ensures order of added indications is kept)
  let indicationSelectionOrder = ["Glioblastoma"];

  // -------------------------------
  // DOM refs
  // -------------------------------
  const indicationChecks = document.getElementById('indicationChecks');
  const countryChecks = document.getElementById('countryChecks');
  const countryAssumptions = document.getElementById('countryAssumptions');
  const peakYearSlidersContainer = document.getElementById('peakYearSlidersContainer');
  const patentExtensionInput = document.getElementById('patentExtensionInput');
  const erosionRate = document.getElementById('erosionRate');
  const erosionRateVal = document.getElementById('erosionRateVal');
  const variableCostSlider = document.getElementById('variableCostSlider');
  const variableCostVal = document.getElementById('variableCostVal');
  const peakSalesVal = document.getElementById('peakSalesVal');
  const peakSalesYear = document.getElementById('peakSalesYear');
  const cumStart = document.getElementById('cumStart');
  const cumEnd = document.getElementById('cumEnd');
  const cumSalesVal = document.getElementById('cumSalesVal');
  const cumSpan = document.getElementById('cumSpan');
  const arrowOverlay = document.getElementById('arrowOverlay');
  const plotDiv = document.getElementById('plot');

  // -------------------------------
  // Helpers
  // -------------------------------
  function fmtShortUSD(n) {
    const sign = n < 0 ? "-" : ""; n = Math.abs(n || 0);
    if (n >= 1e9) return `${sign}$${(n / 1e9).toFixed(1).replace(/\.0$/, '')}B`;
    if (n >= 1e6) return `${sign}$${(n / 1e6).toFixed(0)}M`;
    if (n < 1000) return `${sign}$${(n).toFixed(0)}`;
    return `${sign}$${(n / 1e3).toFixed(0)}K`;
  }
  function fmtUSD(n) { return (n === 0) ? '$0' : n.toLocaleString('en-US', {style:'currency', currency:'USD', maximumFractionDigits:0}); }


  // -------------------------------
  // UI utilities
  // -------------------------------
  function createCheckboxes(container, items, defaultCheckedIndices, onChangeCallback) {
    container.innerHTML = '';
    items.forEach((name, index) => {
      const row = document.createElement('label'); row.className = 'check-row';
      const cb = document.createElement('input'); cb.type = 'checkbox';
      cb.checked = defaultCheckedIndices.includes(index);
      cb.value = name;
      if (name === 'Glioblastoma') { cb.checked = true; cb.disabled = true; }
cb.addEventListener('change', (e) => {
  if (container.id === 'indicationChecks') {
    const ind = e.target.value;
    if (e.target.checked) {
      if (!indicationSelectionOrder.includes(ind)) indicationSelectionOrder.push(ind);
    } else {
      indicationSelectionOrder = indicationSelectionOrder.filter(x => x !== ind);
      if (!indicationSelectionOrder.includes('Glioblastoma')) indicationSelectionOrder.unshift('Glioblastoma');
    }
  } else if (container.id === 'countryChecks') {
    // When toggling regions, ensure India input appears
    ensureIndiaCheckboxInput(e.target);

    // If India is just checked, refresh assumptions immediately
    renderCountryAssumptions();

    // If the inline input exists and has a value, keep arrays in sync
    const inline = e.target.parentNode.querySelector('#indiaPopulationInputInline');
    if (inline) setIndiaPopulation(inline.value * 1e6);
  }

  onChangeCallback(e);
});


      const span = document.createElement('span'); span.textContent = name;
      row.appendChild(cb); row.appendChild(span); container.appendChild(row);
    });
  }

  function fillYearSelectors(sel) {
    sel.innerHTML = '';
    years.forEach((y, i) => { const o = document.createElement('option'); o.value = i; o.textContent = y; sel.appendChild(o); });
  }
  function getSelected(containerId) {
    return Array.from(document.querySelectorAll(`#${containerId} input[type=checkbox]`))
                .filter(cb => cb.checked).map(cb => cb.value);
  }
  const getSelectedGroups = () => getSelected('countryChecks');
  const getSelectedIndications = () => getSelected('indicationChecks');

function renderMarketShareSliders() {
  peakYearSlidersContainer.innerHTML = '';
  const sel = getSelectedGroups();
  const groups = (sel && sel.length) ? sel : groupOrder; // fallback

  groups.forEach(g => {
    const row = document.createElement('div');
    row.className = 'slider-row';

    const label = document.createElement('div');
    label.className = 'small';
    label.innerHTML = `<strong style="color:${groupColors[g]}">${g}:</strong> 
                       <span id="peakShareVal-${g}">${(peakShareByGroup[g] ?? 30)}%</span>`;

    const slider = document.createElement('input');
    slider.type = 'range';
    slider.min = 20; slider.max = 50; slider.step = 1;
    slider.dataset.group = g;
    slider.value = (peakShareByGroup[g] ?? 30);
    slider.style.width = '100%';

    const updateTrack = () => {
      const percent = ((slider.value - slider.min) / (slider.max - slider.min)) * 100;
      slider.style.background = `linear-gradient(to right, ${groupColors[g]} ${percent}%, #e0e0e0 ${percent}%)`;
      const valEl = document.getElementById(`peakShareVal-${g}`);
      if (valEl) valEl.textContent = slider.value + "%";
    };

    peakShareByGroup[g] = +slider.value;
    updateTrack();

    slider.addEventListener('input', e => {
      peakShareByGroup[g] = +e.target.value;
      updateTrack();
      updatePlot();
    });

    row.appendChild(label);
    row.appendChild(slider);
    peakYearSlidersContainer.appendChild(row);
  });
}



function ensureIndiaCheckboxInput(cb) {
  // Only for the India checkbox
  if (!cb || cb.value !== 'India') return;

  // Find/remove if unchecked
  let wrapper = cb.parentNode.querySelector('#indiaPopulationInputInlineWrapper');
  if (!cb.checked) {
    if (wrapper) wrapper.remove();
    return;
  }

  // Create once if missing
  if (!wrapper) {
    wrapper = document.createElement('div');
    wrapper.id = 'indiaPopulationInputInlineWrapper';   // <-- so we can find/remove it
    wrapper.className = 'india-pop-card';

    const label = document.createElement('label');
    label.htmlFor = 'indiaPopulationInputInline';
    label.textContent = 'Addressable population (millions)';

    const input = document.createElement('input');
    input.type = 'number';
    input.id = 'indiaPopulationInputInline';
    input.min = '1';
    input.step = '1';
    input.value = 300; // default shown when India is first checked
    input.style.width = '90px';
    input.title = "Enter India's population in millions";

    const onChange = () => {
      const millions = +input.value || 300;
      const fullPop = millions * 1_000_000;
      setIndiaPopulation(fullPop);     // updates indiaPopulation + India case arrays
      renderCountryAssumptions();      // refresh the assumptions panel text
      updatePlot();                    // refresh the chart & KPIs
    };

    input.addEventListener('input', onChange);
    input.addEventListener('change', onChange);

    wrapper.appendChild(label);
    wrapper.appendChild(input);
    cb.parentNode.appendChild(wrapper);

    // Trigger once so the graph updates immediately when India is first checked
    onChange();
  }
}

// -------------------------------
// Treatment cost sliders (NEW)
// -------------------------------
function renderTreatmentCostSliders() {
  const container = document.getElementById('treatmentCostSliders');
  if (!container) return; // defensive
  container.innerHTML = '';
  const selectedGroups = getSelectedGroups();

  // if no group selected, show nothing
  if (!selectedGroups || selectedGroups.length === 0) return;

  selectedGroups.forEach(g => {
    const wrapper = document.createElement('div');
    wrapper.style.marginBottom = '8px';

    const label = document.createElement('div');
    label.className = 'small';
    label.style.color = groupColors[g] || '#111';
    label.innerHTML = `<strong>${g}</strong>: <span id="treatmentCostVal-${g}">${fmtUSD(currentTreatmentCosts[g] || baseTreatmentCosts[g])}</span>`;
    wrapper.appendChild(label);

    const slider = document.createElement('input');
    slider.type = 'range';
    slider.min = 5000;
    slider.max = 150000;
    slider.step = 1000;
    slider.value = currentTreatmentCosts[g] || baseTreatmentCosts[g];
    slider.style.width = '100%';

    // assign thumb color
    try { slider.style.accentColor = groupColors[g]; } catch(e){}

    // update gradient fill
 const updateTrack = () => {
  const percent = ((slider.value - slider.min) / (slider.max - slider.min)) * 100;
  slider.style.setProperty('--percent', percent + '%');
  slider.style.setProperty('--fill-color', groupColors[g]); // region color
};
    updateTrack();
    slider.addEventListener('input', updateTrack);

    // update cost value + replot
    slider.addEventListener('input', (e) => {
      currentTreatmentCosts[g] = +e.target.value;
      const span = document.getElementById(`treatmentCostVal-${g}`);
      if (span) span.textContent = fmtUSD(currentTreatmentCosts[g]);
      updatePlot();
    });

    wrapper.appendChild(slider);
    container.appendChild(wrapper);
  });
}

  // -------------------------------
  // Market share / adoption curves
  // -------------------------------
function generateMarketShareRamp(targetPct, yearsArr) {
  const out = new Array(yearsArr.length).fill(0);
  const rampYears = 6;
  const target = targetPct / 100;
  const launchI = yearsArr.indexOf(launchYear);
  for (let i = launchI; i < yearsArr.length; i++) {
    const t = i - launchI;
    if (t >= rampYears) out[i] = target;
    else out[i] = target * (t + 1) / rampYears;
  }
  return out;
}


  function buildAdditionalIndAdoptionCurvesAndCostYears() {
    const out = { curves: {}, costYears: {} };
    const extras = indicationSelectionOrder.filter(x => x !== 'Glioblastoma');
    extras.forEach((ind, j) => {
      const costStartIdx = launchIdx + 3 * j;
      const revenueStartIdx = costStartIdx + additionalDelayYears;
      const curve = new Array(years.length).fill(0);
      for (let t = 0; t < years.length; t++) {
        if (t < revenueStartIdx) curve[t] = 0;
        else {
          const rampPos = t - revenueStartIdx;
          if (rampPos >= additionalRampYears) curve[t] = 1.0;
          else curve[t] = Math.min(1, (rampPos + 1) / additionalRampYears);
        }
      }
      out.curves[ind] = curve;
      out.costYears[ind] = costStartIdx;
    });
    return out;
  }

  // -------------------------------
  // Arrow overlay rendering (SVG)
  // -------------------------------
  function renderArrowOverlay(timelineEvents) {
    const tickTextElems = plotDiv.querySelectorAll('.xtick text');
    const axisPath = plotDiv.querySelector('.xaxislayer .domain, .xaxislayer-below .domain, .xaxislayer-above .domain');
    if (!tickTextElems || tickTextElems.length === 0 || !axisPath) {
      setTimeout(() => renderArrowOverlay(timelineEvents), 60);
      return;
    }

    const plotBox = plotDiv.getBoundingClientRect();
    arrowOverlay.setAttribute('width', plotBox.width);
    arrowOverlay.setAttribute('height', plotBox.height);
    arrowOverlay.style.width = plotBox.width + 'px';
    arrowOverlay.style.height = plotBox.height + 'px';
    while (arrowOverlay.firstChild) arrowOverlay.removeChild(arrowOverlay.firstChild);

    const tickCenters = {};
    tickTextElems.forEach(el => {
      const t = (el.textContent || '').trim();
      const b = el.getBoundingClientRect();
      const centerX = (b.left + b.right) / 2 - plotBox.left;
      tickCenters[t] = centerX;
    });

    const axisBBox = axisPath.getBoundingClientRect();
    const axisY = axisBBox.top - plotBox.top + axisBBox.height / 2;

    const usedSlots = {};
    timelineEvents.sort((a,b) => (a.year - b.year) || a.label.localeCompare(b.label));
    timelineEvents.forEach((ev, idx) => {
      const tickLabel = `'${String(ev.year).slice(2)}`; // tick text format
      const cx = tickCenters[tickLabel];
      if (typeof cx === 'undefined') return;

      usedSlots[ev.year] = (usedSlots[ev.year] || 0);
      const slotIdx = usedSlots[ev.year];

      const baseShaft = 28;
      const longMultiplier = (idx % 2 === 0) ? 1.9 : 1.0;
      const slotSpacing = 20;
      const shaftLen = Math.round(baseShaft * longMultiplier + slotIdx * slotSpacing);
      const horizDirection = (idx % 2 === 0) ? -1 : 1;
      const horizNudge = horizDirection * Math.min(28, 6 + Math.floor(slotIdx / 2) * 8);

      const ns = "http://www.w3.org/2000/svg";
      const line = document.createElementNS(ns, 'line');
      line.setAttribute('x1', cx + horizNudge);
      line.setAttribute('x2', cx + horizNudge);
      line.setAttribute('y1', axisY + 6);
      line.setAttribute('y2', axisY + 6 + shaftLen - 8);
      line.setAttribute('stroke', ev.color || '#333');
      line.setAttribute('stroke-width', 2);
      line.setAttribute('stroke-linecap', 'round');
      arrowOverlay.appendChild(line);

      const tri = document.createElementNS(ns, 'polygon');
      const tipW = 8;
      const tipH = 8;
      const px = cx + horizNudge;
      const triPoints = `${px - tipW},${axisY + tipH} ${px + tipW},${axisY + tipH} ${px},${axisY}`;
      tri.setAttribute('points', triPoints);
      tri.setAttribute('fill', ev.color || '#333');
      arrowOverlay.appendChild(tri);

      const text = document.createElementNS(ns, 'text');
      text.setAttribute('x', cx + horizNudge);
      text.setAttribute('y', axisY + 6 + shaftLen + 6);
      text.setAttribute('font-size', '11');
      text.setAttribute('fill', ev.color || '#111');
      text.setAttribute('text-anchor', 'middle');
      text.textContent = ev.label;
      arrowOverlay.appendChild(text);

      usedSlots[ev.year] += 1;
    });
  }

// -------------------------------
// Base assumptions rendering (per-region)
// -------------------------------
function renderCountryAssumptions() {
  countryAssumptions.innerHTML = '';

  const selectedGroups = getSelectedGroups();
  const groupsToShow = (selectedGroups && selectedGroups.length) ? selectedGroups : groupOrder;

  const selectedIndications = getSelectedIndications();
  const inds = (selectedIndications && selectedIndications.length) ? selectedIndications : indicationOrder;

  groupsToShow.forEach(g => {
    const regionPeakShare = (peakShareByGroup[g] ?? 30) / 100;

    const node = document.createElement('div');
    node.className = 'country-card';

    // Build compact list: per indication final treated-at-peak + region total
    let regionTotal = 0;
    let html = `<strong>${g}</strong>`;

    html += `<div class="small" style="margin-top:4px;color:#444;">Addressable patients (at peak):</div>`;

    inds.forEach(ind => {
      const pop = (g === 'India') ? indiaPopulation : basePopulation[g];
      const incidence = incidencePer100k[ind];                 // per 100k
      const totalCases = Math.round(pop * incidence / 100000); // cases/yr
      const neuPct = neurosurgeryPct[ind][g] || 0;             // eligibility
      const addressable = totalCases * neuPct;                  // eligible pool
      const treatedAtPeak = Math.round(addressable * regionPeakShare);

      regionTotal += treatedAtPeak;

      html += `<div class="small">• ${ind}: <strong>~${treatedAtPeak.toLocaleString()}</strong> /yr</div>`;
    });

    // Show region total only if >1 indication is selected
if (inds.length > 1) {
  html += `<div class="small" style="margin-top:6px;border-top:1px dashed #eee;padding-top:6px;">
             <em>Total (selected indications):</em> <strong>~${regionTotal.toLocaleString()}</strong> /yr
           </div>`;
}

// Show neurosurgery rates only for selected indications
const abbr = { "Glioblastoma":"GBM", "Brain Metastasis":"BM", "OPBT":"OPBT" };
const neuList = inds.map(ind => `${abbr[ind]||ind}: ~${Math.round((neurosurgeryPct[ind][g]||0)*100)}%`).join(', ');
html += `<div class="small" style="margin-top:6px;color:#666;">Neurosurgery eligibility used → ${neuList}</div>`;


    node.innerHTML = html;
    countryAssumptions.appendChild(node);
  });
}

function updatePlot() {
  const selectedGroups = getSelectedGroups();
  const selectedIndications = getSelectedIndications();
  const patentExtension = +patentExtensionInput.value || 0;
  const erosion = +erosionRate.value / 100;

  // region-specific prices
  const pricesByGroup = {};
  const selGroups = getSelectedGroups();
  const priceGroups = (selGroups && selGroups.length > 0) ? selGroups : groupOrder;
  priceGroups.forEach(g => {
    pricesByGroup[g] = (currentTreatmentCosts[g] !== undefined) ? currentTreatmentCosts[g] : baseTreatmentCosts[g];
  });

  const variableCostRate = +variableCostSlider.value / 100;

  const traces = [];

  const additionalData = buildAdditionalIndAdoptionCurvesAndCostYears();
  const additionalAdoptionCurves = additionalData.curves;

  const groups = (selectedGroups && selectedGroups.length > 0) ? selectedGroups : [];

  // --- If no regions are selected, clear everything ---
  if (groups.length === 0) {
    Plotly.react('plot', [], {
      margin: { t: 42, r: 18, l: 70, b: 60 },
      xaxis: { title: 'Year', tickvals: years, ticktext: years.map(y => `'${String(y).slice(2)}`) },
      yaxis: { title: 'Net Revenue (USD)' }
    });
    peakSalesVal.textContent = '$0';
    peakSalesYear.textContent = 'Year: —';
    cumSalesVal.textContent = '$0';
    cumSpan.textContent = 'Span: —';
    currentTotalNetRevenues = [];
    countryAssumptions.innerHTML = '';
    while (arrowOverlay.firstChild) arrowOverlay.removeChild(arrowOverlay.firstChild);
    return;
  }

  // Helper to apply LoE erosion
  const applyErosionAfterLoe = (rev, year, loeYear) => {
    if (year > loeYear) {
      const yearsAfter = year - loeYear;
      return rev * Math.pow(1 - erosion, yearsAfter);
    }
    return rev;
  };

  // Collect per-trace GROSS arrays first
  const perTraceGross = [];   // [{name, color, y: number[]}]

  if (groups.length === 1) {
    // --- Single region: stack by indication ---
    const g = groups[0];
    const targetSharePct = (peakShareByGroup[g] ?? 30);
    const targetShare = targetSharePct / 100;
    const shares = generateMarketShareRamp(targetSharePct, years);
    const regionPrice = pricesByGroup[g] || baseTreatmentCosts[g];

    const inds = (selectedIndications.length > 0) ? selectedIndications : indicationOrder;

    inds.forEach(ind => {
      const pop = (g === 'India') ? indiaPopulation : basePopulation[g];
      const incidence = incidencePer100k[ind];
      const neuPct = neurosurgeryPct[ind][g] || 0;
      const yearlyCases = Math.round(pop * incidence / 100000);
      const loeYear = (baseLoeYears[g] || 2040) + patentExtension;

      const yGross = years.map((y, i) => {
        const adoption = (ind === 'Glioblastoma')
          ? shares[i]
          : (((additionalAdoptionCurves[ind] || [])[i] || 0) * targetShare);
        let rev = yearlyCases * neuPct * adoption * regionPrice;
        return applyErosionAfterLoe(rev, y, loeYear);
      });

      perTraceGross.push({
        name: ind,
        color: (indicationColors[ind] && indicationColors[ind][g]) ? indicationColors[ind][g] : groupColors[g],
        y: yGross
      });
    });

  } else {
    // --- Multi-region: stack by region (sum of selected indications) ---
    groups.forEach(g => {
      const targetSharePct = (peakShareByGroup[g] ?? 30);
      const targetShare = targetSharePct / 100;
      const shares = generateMarketShareRamp(targetSharePct, years);
      const regionPrice = pricesByGroup[g] || baseTreatmentCosts[g];

      const inds = (selectedIndications && selectedIndications.length > 0) ? selectedIndications : indicationOrder;

      const yGross = years.map(() => 0);
      const loeYear = (baseLoeYears[g] || 2040) + patentExtension;

      inds.forEach(ind => {
        const pop = (g === 'India') ? indiaPopulation : basePopulation[g];
        const incidence = incidencePer100k[ind];
        const neuPct = neurosurgeryPct[ind][g] || 0;
        const yearlyCases = Math.round(pop * incidence / 100000);

        for (let i = 0; i < years.length; i++) {
          const adoption = (ind === 'Glioblastoma')
            ? shares[i]
            : (((additionalAdoptionCurves[ind] || [])[i] || 0) * targetShare);
          let rev = yearlyCases * neuPct * adoption * regionPrice;
          yGross[i] += applyErosionAfterLoe(rev, years[i], loeYear);
        }
      });

      perTraceGross.push({
        name: g,
        color: groupColors[g],
        y: yGross
      });
    });
  }

  // Convert each trace to NET: multiply by (1 - OpEx%)
  const perTraceNet = perTraceGross.map(t => ({
    name: t.name,
    color: t.color,
    y: t.y.map(v => v * (1 - variableCostRate))
  }));


  // Build Plotly traces (net)
  perTraceNet.forEach(t => {
    traces.push({
      x: years,
      y: t.y,
      type: 'bar',
      name: t.name,
      marker: { color: t.color },
      hoverlabel: { bgcolor: t.color, font: { color: '#fff' } },
      hovertemplate: `<b>${t.name}</b><br>%{x}<br>Net revenue: %{y:$,.0f}<extra></extra>`,
      textposition: 'none'
    });
  });

// Dynamic total costs line (variable OpEx + fixed $30M in 2028)
const variableCosts = years.map((_, i) =>
  perTraceGross.reduce((s, t) => s + t.y[i], 0) * variableCostRate
);
const costsLine = variableCosts.slice();
costsLine[0] += startupCostValue;

traces.push({
  x: years,
  y: costsLine,
  type: 'scatter',
  mode: 'lines',
  name: 'Total costs',
  line: { width: 2 },
  hovertemplate: `<b>Total costs</b><br>%{x}<br>%{y:$,.0f}<extra></extra>`
});


  // Totals & annotations (bars are net of variable OpEx; subtract fixed $30M only in 2028)
const totalsNetBeforeFixed = years.map((_, i) =>
  perTraceNet.reduce((s, t) => s + t.y[i], 0)
);
const totalsNetRevenueByYear = totalsNetBeforeFixed.map((v, i) =>
  i === 0 ? (v - startupCostValue) : v
);


  const annotations = [];
  totalsNetRevenueByYear.forEach((t, i) => {
    if (t > 1_000_000) {
      annotations.push({
        x: years[i],
        y: t > 0 ? t * 1.02 : t * 0.94,
        text: fmtShortUSD(t),
        xanchor: 'center',
        yanchor: t > 0 ? 'bottom' : 'top',
        showarrow: false,
        font: { size: 11, color: '#333' }
      });
    }
  });

  // Axis ranges
  const dataMin = Math.min(...totalsNetRevenueByYear, 0);
  const dataMax = Math.max(...totalsNetRevenueByYear, 0);
  const pad = (dataMax - dataMin) * 0.08 || Math.max(Math.abs(dataMax), Math.abs(dataMin)) * 0.08 || 1;
  const yMin = dataMin - pad;
  const yMax = dataMax + pad;
  const xaxisPositionNormalized = (0 - yMin) / (yMax - yMin);

  const layout = {
    barmode: 'relative',
    margin: { t: 42, r: 18, l: 70, b: 60 },
    xaxis: { 
      title: 'Year', 
      tickmode: 'array', 
      tickvals: years, 
      ticktext: years.map(y => `'${String(y).slice(2)}`), 
      automargin: true, 
      position: xaxisPositionNormalized, 
      gridcolor: '#f3f3f3' 
    },
    yaxis: { 
      title: 'Net Revenue (USD)', 
      automargin: true, 
      autorange: false, 
      range: [yMin, yMax], 
      zeroline: true, 
      zerolinewidth: 2, 
      gridcolor: '#f3f3f3' 
    },
    annotations: annotations,
    showlegend: true,
    legend: { x: 0.01, y: 0.98, font: { size: 12 } },
    hovermode: 'x',
    hoverdistance: 50
  };

  // Timeline arrows
  const timelineEvents = [
    { year: 2028, label: 'Phase II end', color: '#333' },
    { year: 2030, label: 'Launch', color: '#0b5cff' }
  ];
  const extrasLocal = indicationSelectionOrder.filter(x => x !== 'Glioblastoma');
  extrasLocal.forEach((ind, k) => {
    const costStartIdx = launchIdx + 3 * k;
    const revenueStartIdx = costStartIdx + additionalDelayYears;
    if (costStartIdx >= 0 && costStartIdx < years.length) timelineEvents.push({ year: years[costStartIdx], label: `${ind} cost`, color: '#881111' });
    if (revenueStartIdx >= 0 && revenueStartIdx < years.length) timelineEvents.push({ year: years[revenueStartIdx], label: `${ind} revenue begins`, color: '#116688' });
  });

  // Render
  if (!window._plotInitialized) {
    Plotly.newPlot('plot', traces, layout, { responsive: true, displaylogo: false }).then(() => {
      window._plotInitialized = true;
      setTimeout(() => renderArrowOverlay(timelineEvents), 50);
    });
  } else {
    Plotly.react('plot', traces, layout, { responsive: true, displaylogo: false });
    setTimeout(() => renderArrowOverlay(timelineEvents), 50);
  }

  const p = document.getElementById('plot');
  if (p && p.on) p.on('plotly_relayout', () => renderArrowOverlay(timelineEvents));
  window.addEventListener('resize', () => setTimeout(() => renderArrowOverlay(timelineEvents), 60));

  // --- KPIs & break-even color logic ---
  const maxNetRev = Math.max(...totalsNetRevenueByYear);
  const maxRevIndex = totalsNetRevenueByYear.indexOf(maxNetRev);
  peakSalesVal.textContent = fmtShortUSD(maxNetRev);
  peakSalesYear.textContent = 'Year: ' + years[maxRevIndex];
  currentTotalNetRevenues = totalsNetRevenueByYear;

  // Break-even: first year where cumulative net ≥ 0
  let cum = 0, breakevenIndex = -1;
  for (let i = 0; i < totalsNetRevenueByYear.length; i++) {
    cum += totalsNetRevenueByYear[i];
    if (cum >= 0) { breakevenIndex = i; break; }
  }
  const isBeforeBreakeven = (breakevenIndex === -1) || (maxRevIndex < breakevenIndex);
  peakSalesVal.style.color = isBeforeBreakeven ? "#d9534f" : "#00a65a";

  erosionRateVal.textContent = (+erosionRate.value).toFixed(1) + '%';
  variableCostVal.textContent = (+variableCostSlider.value).toFixed(1) + '%';

  renderCountryAssumptions();
  updateCumKPI();
}


// -------------------------------
// Cumulative KPI calculation
// -------------------------------
function updateCumKPI() {
  const startIdx = +cumStart.value;
  const endIdx = +cumEnd.value;

  if (!currentTotalNetRevenues.length || startIdx >= endIdx) {
    cumSalesVal.textContent = '$0';
    cumSpan.textContent = 'Span: —';
    return;
  }

  const sum = currentTotalNetRevenues
    .slice(startIdx, endIdx + 1)
    .reduce((a, b) => a + b, 0);

  cumSalesVal.textContent = fmtShortUSD(sum);
  cumSpan.textContent = `Span: ${years[startIdx]}–${years[endIdx]}`;
}

  // -------------------------------
// Initialization
// -------------------------------
function init() {
  createCheckboxes(indicationChecks, indicationOrder, [0], updatePlot);

  // Keep the same default region selection indices ([0,1,2]) but ensure the handler re-renders
  createCheckboxes(countryChecks, groupOrder, [0,1,2], () => {
    renderMarketShareSliders();
    renderTreatmentCostSliders();
    renderCountryAssumptions();  // <-- force re-render of assumptions when regions change
    updatePlot();
  });

// Manually trigger initial rendering for default region checkboxes
renderMarketShareSliders();
renderTreatmentCostSliders();
renderCountryAssumptions();
updatePlot();

  fillYearSelectors(cumStart);
  fillYearSelectors(cumEnd);
  cumStart.selectedIndex = 0;
  cumEnd.selectedIndex = years.length - 1;

  if (!indicationSelectionOrder.includes('Glioblastoma')) {
    indicationSelectionOrder.unshift('Glioblastoma');
  }

  document.querySelectorAll('#controls input[type=range], #patentExtensionInput')
    .forEach(el => el.addEventListener('input', updatePlot));

  cumStart.addEventListener('change', updateCumKPI);
  cumEnd.addEventListener('change', updateCumKPI);

// force plot once defaults are set
setTimeout(() => updatePlot(), 0);

  // -------------------------------
  // Neutral slider color setup
  // -------------------------------
  ['erosionRate','variableCostSlider'].forEach(id => {
    const s = document.getElementById(id);
    if (!s) return;

    const updateNeutral = () => {
      const percent = ((s.value - s.min) / (s.max - s.min)) * 100;
      s.style.setProperty('--percent', percent + '%');
      s.style.setProperty('--fill-color', '#888'); // neutral gray
      s.style.background = `linear-gradient(to right, var(--fill-color) ${percent}%, #e0e0e0 ${percent}%)`;
    };

    updateNeutral();
    s.addEventListener('input', updateNeutral);
  });
}

init();
</script>
</body>
</html>
