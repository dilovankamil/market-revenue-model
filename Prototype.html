<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Market Model — Revenues (2028–2047)</title>
  <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
  <style>
    :root{--panel-bg:#e6f0ef;--muted:#666;--card-bg:#fff;--accent:#0b5cff}
    *{box-sizing:border-box}
    body{margin:0;font-family:Inter,Arial,Helvetica,sans-serif;display:flex;height:100vh;color:#111}
    #controls{width:320px;border-right:1px solid #e6e6e6;padding:14px;background:var(--panel-bg);overflow:auto}
    #graphWrap{
  flex:1;
  display:flex;
  flex-direction:column;
  padding:12px;
  background:#e6f0ef; /* new background, same muted color */
}
    .card{background:var(--card-bg);border:1px solid #e9e9e9;border-radius:8px;padding:10px;margin-bottom:12px}
    label{display:block;font-weight:600;margin-bottom:6px;font-size:13px}
    .small{font-size:12px;color:var(--muted)}
    input[type="range"]{width:100%}
    select, input[type="number"]{width:100%;padding:6px;border:1px solid #ddd;border-radius:6px}
    .checks{display:grid;gap:6px}
    .check-row{display:flex;align-items:center;gap:8px;font-size:13px}
    #plot{height:64vh; position: relative;} /* overlay sits inside */
    #arrowOverlay { position:absolute; left:0; top:0; width:100%; height:100%; pointer-events:none; }
    .kpis{display:flex;gap:12px;margin-top:12px}
    .kpi{flex:1;background:var(--card-bg);border:1px solid #e9e9e9;border-radius:8px;padding:10px;text-align:center}
    .kpi .big{font-size:18px;font-weight:700;margin-top:8px}
    .country-card{margin-bottom:8px;padding:8px;border-radius:6px;background:#fff;border:1px solid #f0f0f0;font-size:13px}
    .slider-row { margin-bottom: 12px; }
    .ref { font-size:11px;color:#666;margin-top:8px; line-height:1.35;}
  </style>
</head>
<body>
  <div id="controls">
    <h2>Model parameters</h2>
    
    <div class="card">
        <label>Indications</label>
        <div id="indicationChecks" class="checks"></div>
    </div>

    <div class="card">
      <label>Regions</label>
      <div id="countryChecks" class="checks"></div>
    </div>
    
    <div class="card">
        <label>Peak Market Share Year (by Region)</label>
        <div id="peakYearSlidersContainer"></div>
    </div>

    <div class="card">
      <label for="patentExtensionInput">Patent Exclusivity Extension (+ Years)</label>
      <input id="patentExtensionInput" type="number" min="0" max="10" step="1" value="0" />
      <div class="small" style="margin-top:6px">Applies to all selected regions.</div>
      
      <div style="height:10px"></div>
      <label for="erosionRate">Post-LoE annual erosion (%)</label>
      <input id="erosionRate" type="range" min="0.5" max="5" step="0.1" value="2.5" />
      <div class="small">Compounding decline after LoE: <span id="erosionRateVal">2.5%</span>/yr</div>
    </div>

    <div class="card">
      <label for="treatmentCost">Treatment cost (USD)</label>
      <input id="treatmentCost" type="range" min="50000" max="150000" step="1000" value="100000" />
      <div class="small"><span id="treatmentCostVal">$100,000</span></div>
    </div>
    
    <div class="card">
        <label>Cost Parameters</label>
        <label for="variableCostSlider" class="small" style="font-weight:normal;margin-bottom:4px;">Operational Cost Rate (% of Gross Revenue)</label>
        <input id="variableCostSlider" type="range" min="1" max="10" step="0.1" value="5" />
        <div class="small">Current rate: <span id="variableCostVal">5.0%</span>/yr</div>
        <div class="small" style="margin-top:8px;">Note: A flat $30M cost for the Phase II trial is applied in 2028 (moved to Base assumptions text).</div>
    </div>

    <div class="card">
      <h3 style="margin:0 0 8px 0">Base assumptions (read-only)</h3>
      <div id="countryAssumptions"></div>

      <!-- New explanatory notes -->
      <div id="assumptionNotes" class="small" style="margin-top:8px; line-height:1.45">
        <div><strong>Patient figures</strong>: For each region, the counts shown per indication (<strong>Glioblastoma</strong>, <strong>Brain Metastasis</strong>, <strong>OPBT</strong>) are the incidence values used by the model (same years window and neurosurgery filters). If data is insufficient in a specific country or region, assumptions are based on other regions' data.</div>
        <div style="margin-top:8px;"><strong>Clinical costs</strong>: A flat <strong>$30M</strong> Phase II cost is applied in <strong>2028</strong>. Each additional indication incurs a <strong>$25M</strong> bridging study cost, applied at <strong>Launch (2030)</strong> for the first add-on, and then at <strong>+3 years</strong> for subsequent add-ons.</div>
        <div style="margin-top:8px;"><strong>Operational cost slider</strong>: Covers <strong>Marketing</strong>, <strong>CMC</strong>, <strong>COGs</strong>, and <strong>FTE</strong> (expressed as % of gross revenue).</div>

        <div style="margin-top:10px"><strong>Sources</strong>:</div>
        <div class="ref">
          https://academic.oup.com/neuro-oncology/article/23/9/1447/6256866<br>
          https://www.ncbi.nlm.nih.gov/books/NBK470246/<br>
          https://www.nature.com/articles/s43856-024-00445-7<br>
          https://www.nejm.org/doi/full/10.1056/NEJM199002223220802<br>
          https://pmc.ncbi.nlm.nih.gov/articles/PMC9533228<br>
          https://statistik.incanet.se/CNS/<br>
          https://www.nature.com/articles/s41598-024-79170-z<br>
          https://www.worldometers.info/world-population/<br>
          https://glioblastomafoundation.org/news/glioblastoma-multiforme<br>
          https://academic.oup.com/nop/article/6/1/37/5001149
        </div>
      </div>
    </div>
  </div>

  <div id="graphWrap">
    <div id="plot">
      <svg id="arrowOverlay" xmlns="http://www.w3.org/2000/svg"></svg>
    </div>

    <div class="kpis">
      <div class="kpi">
        <div class="small">Peak Revenue (USD)</div>
        <div class="big" id="peakSalesVal">$0</div>
        <div class="small" id="peakSalesYear">Year: —</div>
      </div>

      <div class="kpi">
        <div class="small">Cumulative Revenue</div>
        <div style="display:flex;gap:8px;align-items:center;justify-content:center;margin-top:6px">
          <select id="cumStart"></select><div class="small">→</div><select id="cumEnd"></select>
        </div>
        <div class="big" id="cumSalesVal">$0</div>
        <div class="small" id="cumSpan">Span: —</div>
      </div>
    </div>
  </div>

  <script>
  // -------------------------------
  // Model years & anchors
  // -------------------------------
  const years = Array.from({length: 20}, (_, i) => 2028 + i); // 2028..2047
  const launchYear = 2030;
  const launchIdx = Math.max(0, years.indexOf(launchYear));

  // -------------------------------
  // Epidemiology data (UPDATED per your request)
  // -------------------------------
  // Flat yearly incidence arrays using the exact numbers you provided
  const allIndicationsData = {
    "Glioblastoma": {
      cases: {
        "EU4+UK": Array(years.length).fill(11298),
        "US":     Array(years.length).fill(10879),
        "Japan":  Array(years.length).fill(1387)
      },
      neurosurgeryPct: { "EU4+UK": 0.70, "US": 0.73, "Japan": 0.70 }
    },
    "Brain Metastasis": {
      cases: {
        "EU4+UK": Array(years.length).fill(45903),
        "US":     Array(years.length).fill(49964),
        "Japan":  Array(years.length).fill(16616)
      },
      neurosurgeryPct: { "EU4+UK": 0.25, "US": 0.25, "Japan": 0.25 }
    },
    "OPBT": {
      cases: {
        "EU4+UK": Array(years.length).fill(2445),
        "US":     Array(years.length).fill(3344),
        "Japan":  Array(years.length).fill(453)
      },
      neurosurgeryPct: { "EU4+UK": 0.33, "US": 0.33, "Japan": 0.33 }
    }
  };

  const indicationOrder = ["Glioblastoma", "Brain Metastasis", "OPBT"];
  const groupOrder = ["EU4+UK", "US", "Japan"];
  const groupColors = { "EU4+UK": "#2f6df6", "US": "#00b37e", "Japan": "#f59e0b" };

  // -------------------------------
  // Parameters & state
  // -------------------------------
  const baseLoeYears = { "EU4+UK": 2040, "US": 2037, "Japan": 2040 };
  let peakYearsByGroup = { "EU4+UK": 2036, "US": 2036, "Japan": 2036 };
  let currentTotalNetRevenues = [];

  const additionalDelayYears = 3;   // revenue starts after delay from cost-start
  const additionalRampYears = 4;
  const additionalStartCostValue = 25000000; // $25M per extra indication
  const startupCostValue = 30000000; // $30M Phase II cost applied in 2028 (per your text)

  // Selection order (ensures order of added indications is kept)
  let indicationSelectionOrder = ["Glioblastoma"];

  // -------------------------------
  // DOM refs
  // -------------------------------
  const indicationChecks = document.getElementById('indicationChecks');
  const countryChecks = document.getElementById('countryChecks');
  const countryAssumptions = document.getElementById('countryAssumptions');
  const peakYearSlidersContainer = document.getElementById('peakYearSlidersContainer');
  const patentExtensionInput = document.getElementById('patentExtensionInput');
  const erosionRate = document.getElementById('erosionRate');
  const erosionRateVal = document.getElementById('erosionRateVal');
  const treatmentCost = document.getElementById('treatmentCost');
  const treatmentCostVal = document.getElementById('treatmentCostVal');
  const variableCostSlider = document.getElementById('variableCostSlider');
  const variableCostVal = document.getElementById('variableCostVal');
  const peakSalesVal = document.getElementById('peakSalesVal');
  const peakSalesYear = document.getElementById('peakSalesYear');
  const cumStart = document.getElementById('cumStart');
  const cumEnd = document.getElementById('cumEnd');
  const cumSalesVal = document.getElementById('cumSalesVal');
  const cumSpan = document.getElementById('cumSpan');
  const arrowOverlay = document.getElementById('arrowOverlay');
  const plotDiv = document.getElementById('plot');

  // -------------------------------
  // Helpers
  // -------------------------------
  function fmtShortUSD(n) {
    const sign = n < 0 ? "-" : ""; n = Math.abs(n || 0);
    if (n >= 1e9) return `${sign}$${(n / 1e9).toFixed(1).replace(/\.0$/, '')}B`;
    if (n >= 1e6) return `${sign}$${(n / 1e6).toFixed(0)}M`;
    if (n < 1000) return `${sign}$${(n).toFixed(0)}`;
    return `${sign}$${(n / 1e3).toFixed(0)}K`;
  }
  function fmtUSD(n) { return (n === 0) ? '$0' : n.toLocaleString('en-US', {style:'currency', currency:'USD', maximumFractionDigits:0}); }

  // -------------------------------
  // UI utilities
  // -------------------------------
  function createCheckboxes(container, items, defaultCheckedIndices, onChangeCallback) {
    container.innerHTML = '';
    items.forEach((name, index) => {
      const row = document.createElement('label'); row.className = 'check-row';
      const cb = document.createElement('input'); cb.type = 'checkbox';
      cb.checked = defaultCheckedIndices.includes(index);
      cb.value = name;
      if (name === 'Glioblastoma') { cb.checked = true; cb.disabled = true; }
      cb.addEventListener('change', (e) => {
        if (container.id === 'indicationChecks') {
          const ind = e.target.value;
          if (e.target.checked) {
            if (!indicationSelectionOrder.includes(ind)) indicationSelectionOrder.push(ind);
          } else {
            indicationSelectionOrder = indicationSelectionOrder.filter(x => x !== ind);
            if (!indicationSelectionOrder.includes('Glioblastoma')) indicationSelectionOrder.unshift('Glioblastoma');
          }
        }
        onChangeCallback(e);
      });
      const span = document.createElement('span'); span.textContent = name;
      row.appendChild(cb); row.appendChild(span); container.appendChild(row);
    });
  }

  function fillYearSelectors(sel) {
    sel.innerHTML = '';
    years.forEach((y, i) => { const o = document.createElement('option'); o.value = i; o.textContent = y; sel.appendChild(o); });
  }
  function getSelected(containerId) {
    return Array.from(document.querySelectorAll(`#${containerId} input[type=checkbox]`))
                .filter(cb => cb.checked).map(cb => cb.value);
  }
  const getSelectedGroups = () => getSelected('countryChecks');
  const getSelectedIndications = () => getSelected('indicationChecks');

  function renderPeakYearSliders() {
    peakYearSlidersContainer.innerHTML = '';
    const selectedGroups = getSelectedGroups();
    selectedGroups.forEach(g => {
      const row = document.createElement('div'); row.className = 'slider-row';
      const label = document.createElement('div'); label.className = 'small';
      label.innerHTML = `<strong>${g}:</strong> <span id="peakYearVal-${g}">${peakYearsByGroup[g]}</span>`;
      const slider = document.createElement('input'); slider.type = 'range';
      slider.min = 2034; slider.max = 2040; slider.step = 1;
      slider.dataset.group = g; slider.value = peakYearsByGroup[g];
      slider.addEventListener('input', (e) => {
        const group = e.target.dataset.group;
        peakYearsByGroup[group] = parseInt(e.target.value, 10);
        document.getElementById(`peakYearVal-${group}`).textContent = peakYearsByGroup[group];
        updatePlot();
      });
      row.appendChild(label); row.appendChild(slider);
      peakYearSlidersContainer.appendChild(row);
    });
  }

  // -------------------------------
  // Market share / adoption curves
  // -------------------------------
  function generateMarketShareCurve(peakShareYear, loeYear, erosionFraction, launchYearAnchor = launchYear) {
    const out = new Array(years.length).fill(0);
    const peakIdx = years.indexOf(peakShareYear);
    const loeIdx = years.indexOf(loeYear);
    const launchI = Math.max(0, years.indexOf(launchYearAnchor));
    const effectivePeak = (peakIdx >= launchI) ? peakIdx : launchI;
    const riseSpan = Math.max(0, effectivePeak - launchI);
    const denom = riseSpan + 1;
    for (let i = 0; i < years.length; i++) {
      if (i < launchI) out[i] = 0;
      else if (i <= effectivePeak) {
        const rel = (i - launchI + 1) / denom;
        out[i] = Math.pow(rel, 2);
      } else out[i] = 1.0;
    }
    if (loeIdx !== -1) {
      for (let i = loeIdx + 1; i < years.length; i++) out[i] = Math.pow(1 - erosionFraction, i - loeIdx);
    }
    return out.map(s => Math.max(0, Math.min(1, s)));
  }

  function buildAdditionalIndAdoptionCurvesAndCostYears() {
    const out = { curves: {}, costYears: {} };
    const extras = indicationSelectionOrder.filter(x => x !== 'Glioblastoma');
    extras.forEach((ind, j) => {
      const costStartIdx = launchIdx + 3 * j;
      const revenueStartIdx = costStartIdx + additionalDelayYears;
      const curve = new Array(years.length).fill(0);
      for (let t = 0; t < years.length; t++) {
        if (t < revenueStartIdx) curve[t] = 0;
        else {
          const rampPos = t - revenueStartIdx;
          if (rampPos >= additionalRampYears) curve[t] = 1.0;
          else curve[t] = Math.min(1, (rampPos + 1) / additionalRampYears);
        }
      }
      out.curves[ind] = curve;
      out.costYears[ind] = costStartIdx;
    });
    return out;
  }

  // -------------------------------
  // Arrow overlay rendering (SVG)
  // -------------------------------
  function renderArrowOverlay(timelineEvents) {
    const tickTextElems = plotDiv.querySelectorAll('.xtick text');
    const axisPath = plotDiv.querySelector('.xaxislayer .domain, .xaxislayer-below .domain, .xaxislayer-above .domain');
    if (!tickTextElems || tickTextElems.length === 0 || !axisPath) {
      setTimeout(() => renderArrowOverlay(timelineEvents), 60);
      return;
    }

    const plotBox = plotDiv.getBoundingClientRect();
    arrowOverlay.setAttribute('width', plotBox.width);
    arrowOverlay.setAttribute('height', plotBox.height);
    arrowOverlay.style.width = plotBox.width + 'px';
    arrowOverlay.style.height = plotBox.height + 'px';
    while (arrowOverlay.firstChild) arrowOverlay.removeChild(arrowOverlay.firstChild);

    const tickCenters = {};
    tickTextElems.forEach(el => {
      const t = (el.textContent || '').trim();
      const b = el.getBoundingClientRect();
      const centerX = (b.left + b.right) / 2 - plotBox.left;
      tickCenters[t] = centerX;
    });

    const axisBBox = axisPath.getBoundingClientRect();
    const axisY = axisBBox.top - plotBox.top + axisBBox.height / 2;

    const usedSlots = {};
    timelineEvents.sort((a,b) => (a.year - b.year) || a.label.localeCompare(b.label));
    timelineEvents.forEach((ev, idx) => {
      const tickLabel = `'${String(ev.year).slice(2)}`; // tick text format
      const cx = tickCenters[tickLabel];
      if (typeof cx === 'undefined') return;

      usedSlots[ev.year] = (usedSlots[ev.year] || 0);
      const slotIdx = usedSlots[ev.year];

      const baseShaft = 28;
      const longMultiplier = (idx % 2 === 0) ? 1.9 : 1.0;
      const slotSpacing = 20;
      const shaftLen = Math.round(baseShaft * longMultiplier + slotIdx * slotSpacing);
      const horizDirection = (idx % 2 === 0) ? -1 : 1;
      const horizNudge = horizDirection * Math.min(28, 6 + Math.floor(slotIdx / 2) * 8);

      const ns = "http://www.w3.org/2000/svg";
      const line = document.createElementNS(ns, 'line');
      line.setAttribute('x1', cx + horizNudge);
      line.setAttribute('x2', cx + horizNudge);
      line.setAttribute('y1', axisY + 6);
      line.setAttribute('y2', axisY + 6 + shaftLen - 8);
      line.setAttribute('stroke', ev.color || '#333');
      line.setAttribute('stroke-width', 2);
      line.setAttribute('stroke-linecap', 'round');
      arrowOverlay.appendChild(line);

      const tri = document.createElementNS(ns, 'polygon');
      const tipW = 8;
      const tipH = 8;
      const px = cx + horizNudge;
      const triPoints = `${px - tipW},${axisY + tipH} ${px + tipW},${axisY + tipH} ${px},${axisY}`;
      tri.setAttribute('points', triPoints);
      tri.setAttribute('fill', ev.color || '#333');
      arrowOverlay.appendChild(tri);

      const text = document.createElementNS(ns, 'text');
      text.setAttribute('x', cx + horizNudge);
      text.setAttribute('y', axisY + 6 + shaftLen + 6);
      text.setAttribute('font-size', '11');
      text.setAttribute('fill', ev.color || '#111');
      text.setAttribute('text-anchor', 'middle');
      text.textContent = ev.label;
      arrowOverlay.appendChild(text);

      usedSlots[ev.year] += 1;
    });
  }

  // -------------------------------
  // Base assumptions rendering (per-region)
  // -------------------------------
  function renderCountryAssumptions() {
    countryAssumptions.innerHTML = '';
    const selectedGroups = getSelectedGroups();
    const selectedIndications = getSelectedIndications();

    // If nothing selected (edge), default to all regions
    const groupsToShow = (selectedGroups && selectedGroups.length > 0) ? selectedGroups : Object.keys(allIndicationsData.Glioblastoma.cases);

    groupsToShow.forEach(g => {
      const node = document.createElement('div'); node.className = 'country-card';
      let html = `<strong>${g}</strong>`;

      // Show each indication exactly as it is in the model (average across years)
      const inds = (selectedIndications && selectedIndications.length > 0) ? selectedIndications : Object.keys(allIndicationsData);
      inds.forEach(indName => {
        const indData = allIndicationsData[indName];
        if (!indData || !indData.cases[g]) return;
        const casesArr = indData.cases[g].slice(0, years.length);
        const avgCases = Math.round(casesArr.reduce((a,b) => a + (b||0), 0) / (casesArr.length || 1));
        const neuPct = indData.neurosurgeryPct[g] || 0;
        html += `<div class="small">${indName}: ~${avgCases.toLocaleString()} pts/yr (neurosurg: ${Math.round(neuPct*100)}%)</div>`;
      });

      node.innerHTML = html;
      countryAssumptions.appendChild(node);
    });
  }

  // -------------------------------
  // Main plotting logic (unchanged except uses updated data)
  // -------------------------------
  function updatePlot() {
    const selectedGroups = getSelectedGroups();
    const selectedIndications = getSelectedIndications();
    const patentExtension = +patentExtensionInput.value || 0;
    const erosion = +erosionRate.value / 100;
    const price = +treatmentCost.value;
    const variableCostRate = +variableCostSlider.value / 100;

    const traces = [];
    const totalsGrossRevenueByYear = years.map(() => 0);
    const regionalGrossRevenueByYear = {};
    const regionalPotentialByYear = {};

    const additionalData = buildAdditionalIndAdoptionCurvesAndCostYears();
    const additionalAdoptionCurves = additionalData.curves;

    const groups = (selectedGroups && selectedGroups.length>0) ? selectedGroups : groupOrder;

    groups.forEach(g => {
      const peakShareYear = peakYearsByGroup[g];
      const finalLoeYear = (baseLoeYears[g] || 2040) + patentExtension;
      const shares = generateMarketShareCurve(peakShareYear, finalLoeYear, erosion, launchYear);
      const grossRevenue = years.map(() => 0);
      const potential = years.map(() => 0);

      const inds = (selectedIndications && selectedIndications.length>0) ? selectedIndications : Object.keys(allIndicationsData);

      inds.forEach(ind => {
        const indData = allIndicationsData[ind];
        if (!indData || !indData.cases[g]) return;
        const casesArr = indData.cases[g].slice(0, years.length);
        for (let i=0;i<years.length;i++) {
          const cases = casesArr[i] || 0;
          const neuPct = indData.neurosurgeryPct[g] || 0;
          potential[i] += cases * neuPct * price;
          let adoption = 0;
          if (ind === 'Glioblastoma') adoption = shares[i];
          else adoption = (additionalAdoptionCurves[ind] || new Array(years.length).fill(0))[i] || 0;
          grossRevenue[i] += cases * neuPct * adoption * price;
        }
      });

      regionalGrossRevenueByYear[g] = grossRevenue;
      regionalPotentialByYear[g] = potential;
      grossRevenue.forEach((val,i) => totalsGrossRevenueByYear[i] += val);
    });

    const totalCostsByYear = totalsGrossRevenueByYear.map(gross => gross * variableCostRate);
    totalCostsByYear[0] += startupCostValue;

    const extras = indicationSelectionOrder.filter(x => x !== 'Glioblastoma');
    extras.forEach((ind,k) => {
      const costStartIdx = launchIdx + 3 * k;
      if (costStartIdx >= 0 && costStartIdx < years.length) totalCostsByYear[costStartIdx] += additionalStartCostValue;
    });

    const potentialTotalsByYear = years.map((_, i) => {
      return groups.reduce((s,g) => s + (regionalPotentialByYear[g]?.[i] || 0), 0);
    });

    groups.forEach(g => {
      const regionNetFull = [];
      const regionNetClipped = [];
      const hoverText = [];
      for (let i=0;i<years.length;i++) {
        const grossRegion = regionalGrossRevenueByYear[g][i] || 0;
        const grossTotal = totalsGrossRevenueByYear[i] || 0;
        let costShare = 1 / groups.length;
        if (grossTotal > 0) costShare = grossRegion / grossTotal;
        else {
          const potTotal = potentialTotalsByYear[i];
          if (potTotal > 0) costShare = (regionalPotentialByYear[g]?.[i] || 0) / potTotal;
          else costShare = 1 / groups.length;
        }
        const costForRegion = totalCostsByYear[i] * costShare;
        const netFull = grossRegion - costForRegion;
        regionNetFull.push(netFull);
        regionNetClipped.push(Math.max(0, netFull));
        const revenueToShow = netFull > 0 ? fmtUSD(Math.round(netFull)) : fmtUSD(0);
        hoverText.push(`Revenue: ${revenueToShow}`);
      }

      traces.push({
        x: years, y: regionNetClipped, type: 'bar', name: g, marker: { color: groupColors[g] },
        text: hoverText, hovertemplate: `<b>${g} Revenue</b><br>%{x}<br>%{text}<extra></extra>`, customdata: regionNetFull
      });
    });

    traces.push({
      x: years, y: totalCostsByYear, type: 'scatter', mode: 'lines', name: 'Total Costs',
      line: { color: 'rgba(239, 83, 80, 0.8)', width: 2.5 },
      hovertemplate: `<b>Costs</b><br>%{x}<br>Total Cost: %{y:$,.0f}<extra></extra>`
    });

    const totalsNetRevenueByYear = years.map((_, i) => totalsGrossRevenueByYear[i] - totalCostsByYear[i]);

    const annotations = [];
    totalsNetRevenueByYear.forEach((t,i) => {
      if (t > 1_000_000) annotations.push({ x: years[i], y: t, text: fmtShortUSD(t), xanchor: 'center', yanchor: 'bottom', showarrow: false, font:{size:11,color:'#333'}});
    });

    const dataMin = Math.min(...totalsNetRevenueByYear, ...totalCostsByYear, 0);
    const dataMax = Math.max(...totalsNetRevenueByYear, ...totalCostsByYear, 0);
    const pad = (dataMax - dataMin) * 0.08 || Math.max(Math.abs(dataMax), Math.abs(dataMin)) * 0.08 || 1;
    const yMin = dataMin - pad;
    const yMax = dataMax + pad;
    const xaxisPositionNormalized = (0 - yMin) / (yMax - yMin);

    const layout = {
      barmode: 'relative',
      margin: { t: 42, r: 18, l: 70, b: 60 },
      xaxis: { title:'Year', tickmode:'array', tickvals: years, ticktext: years.map(y => `'${String(y).slice(2)}`), automargin:true, position: xaxisPositionNormalized },
      yaxis: { title:'Revenue / Cost (USD)', automargin:true, autorange:false, range:[yMin,yMax], zeroline:true, zerolinewidth:2 },
      annotations: annotations,
      showlegend: true,
      legend: { x: 0.01, y: 0.98 }
    };

    Plotly.newPlot('plot', traces, layout, { responsive:true, displaylogo:false }).then(() => {
      const timelineEvents = [
        { year: 2028, label: 'Phase II end', color: '#333' },
        { year: 2030, label: 'Launch', color: '#0b5cff' }
      ];
      const extrasLocal = indicationSelectionOrder.filter(x => x !== 'Glioblastoma');
      extrasLocal.forEach((ind,k) => {
        const costStartIdx = launchIdx + 3 * k;
        const revenueStartIdx = costStartIdx + additionalDelayYears;
        if (costStartIdx >=0 && costStartIdx < years.length) timelineEvents.push({ year: years[costStartIdx], label: `${ind} cost`, color:'#881111' });
        if (revenueStartIdx >=0 && revenueStartIdx < years.length) timelineEvents.push({ year: years[revenueStartIdx], label: `${ind} revenue begins`, color:'#116688' });
      });
      setTimeout(() => renderArrowOverlay(timelineEvents), 50);
    });

    const p = document.getElementById('plot');
    if (p && p.on) {
      p.on('plotly_relayout', () => {
        const timelineEvents = [
          { year: 2028, label: 'Phase II end', color: '#333' },
          { year: 2030, label: 'Launch', color: '#0b5cff' }
        ];
        const extrasLocal = indicationSelectionOrder.filter(x => x !== 'Glioblastoma');
        extrasLocal.forEach((ind,k) => {
          const costStartIdx = launchIdx + 3 * k;
          const revenueStartIdx = costStartIdx + additionalDelayYears;
          if (costStartIdx >=0 && costStartIdx < years.length) timelineEvents.push({ year: years[costStartIdx], label: `${ind} cost`, color:'#881111' });
          if (revenueStartIdx >=0 && revenueStartIdx < years.length) timelineEvents.push({ year: years[revenueStartIdx], label: `${ind} revenue begins`, color:'#116688' });
        });
        renderArrowOverlay(timelineEvents);
      });
    }
    window.addEventListener('resize', () => {
      const timelineEvents = [
        { year: 2028, label: 'Phase II end', color: '#333' },
        { year: 2030, label: 'Launch', color: '#0b5cff' }
      ];
      const extrasLocal = indicationSelectionOrder.filter(x => x !== 'Glioblastoma');
      extrasLocal.forEach((ind,k) => {
        const costStartIdx = launchIdx + 3 * k;
        const revenueStartIdx = costStartIdx + additionalDelayYears;
        if (costStartIdx >=0 && costStartIdx < years.length) timelineEvents.push({ year: years[costStartIdx], label: `${ind} cost`, color:'#881111' });
        if (revenueStartIdx >=0 && revenueStartIdx < years.length) timelineEvents.push({ year: years[revenueStartIdx], label: `${ind} revenue begins`, color:'#116688' });
      });
      setTimeout(() => renderArrowOverlay(timelineEvents), 60);
    });

    const maxNetRev = Math.max(...totalsNetRevenueByYear);
    const maxRevIndex = totalsNetRevenueByYear.indexOf(maxNetRev);
    peakSalesVal.textContent = fmtShortUSD(maxNetRev);
    peakSalesYear.textContent = 'Year: ' + years[maxRevIndex];
    currentTotalNetRevenues = totalsNetRevenueByYear;
    updateCumKPI();

    erosionRateVal.textContent = (+erosionRate.value).toFixed(1) + '%';
    treatmentCostVal.textContent = fmtUSD(price);
    variableCostVal.textContent = (+variableCostSlider.value).toFixed(1) + '%';
    renderCountryAssumptions();
  }

  // -------------------------------
  // Cum KPI
  // -------------------------------
  function updateCumKPI() {
    if (!currentTotalNetRevenues || currentTotalNetRevenues.length === 0) return;
    const si = +cumStart.value; const ei = +cumEnd.value;
    const s = Math.min(si, ei); const e = Math.max(si, ei);
    const sum = currentTotalNetRevenues.slice(s, e + 1).reduce((a, b) => a + b, 0);
    cumSalesVal.textContent = fmtShortUSD(sum);
    cumSpan.textContent = `${years[s]} → ${years[e]} (${e - s + 1} yrs)`;
  }

  // -------------------------------
  // Initialization
  // -------------------------------
  function init() {
    createCheckboxes(indicationChecks, indicationOrder, [0], updatePlot);
    createCheckboxes(countryChecks, groupOrder, [0,1,2], () => { renderPeakYearSliders(); updatePlot(); });
    fillYearSelectors(cumStart);
    fillYearSelectors(cumEnd);
    cumStart.selectedIndex = 0;
    cumEnd.selectedIndex = years.length - 1;

    if (!indicationSelectionOrder.includes('Glioblastoma')) indicationSelectionOrder.unshift('Glioblastoma');

    document.querySelectorAll('#controls input[type=range], #patentExtensionInput').forEach(el => el.addEventListener('input', updatePlot));
    cumStart.addEventListener('change', updateCumKPI);
    cumEnd.addEventListener('change', updateCumKPI);

    renderPeakYearSliders();
    updatePlot();
  }

  init();
  </script>
</body>
</html>
