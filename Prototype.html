<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Market Model — Revenues (2028–2047)</title>
  <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
<style>
  :root{--panel-bg:#e6f0ef;--muted:#666;--card-bg:#fff;--accent:#0b5cff}
  *{box-sizing:border-box}
  body{margin:0;font-family:Inter,Arial,Helvetica,sans-serif;display:flex;height:100vh;color:#111}
  #controls{width:320px;border-right:1px solid #e6e6e6;padding:14px;background:var(--panel-bg);overflow:auto}
  #graphWrap{
    flex:1;
    display:flex;
    flex-direction:column;
    padding:12px;
    background:#e6f0ef; /* new background, same muted color */
  }

/* Generic track baseline */
input[type="range"] {
  width: 100%;
  -webkit-appearance: none;
  appearance: none;
  height: 6px;
  border-radius: 3px;
  border: 1px solid #ddd;
  background: #eee; /* default neutral track */
  background-image: linear-gradient(to right, var(--fill-color, #888) var(--percent,0%), #eee var(--percent,0%));
}

/* Thumb */
input[type="range"]::-webkit-slider-thumb {
  -webkit-appearance: none;
  appearance: none;
  width: 14px;
  height: 14px;
  border-radius: 50%;
  background: var(--fill-color, #888);
  cursor: pointer;
  border: 1px solid #333;
  position: relative;
  z-index: 2;
}

input[type="range"]::-moz-range-thumb {
  width: 14px;
  height: 14px;
  border-radius: 50%;
  background: var(--fill-color, #888);
  cursor: pointer;
  border: 1px solid #333;
}


  .card{background:var(--card-bg);border:1px solid #e9e9e9;border-radius:8px;padding:10px;margin-bottom:12px}
  label{display:block;font-weight:600;margin-bottom:6px;font-size:13px}
  .small{font-size:12px;color:var(--muted)}
  select, input[type="number"]{width:100%;padding:6px;border:1px solid #ddd;border-radius:6px}
  .checks{display:grid;gap:6px}
  .check-row{display:flex;align-items:center;gap:8px;font-size:13px}
  #plot{height:64vh; position: relative;} /* overlay sits inside */
  #arrowOverlay { position:absolute; left:0; top:0; width:100%; height:100%; pointer-events:none; }
  .kpis{display:flex;gap:12px;margin-top:12px}
  .kpi{flex:1;background:var(--card-bg);border:1px solid #e9e9e9;border-radius:8px;padding:10px;text-align:center}
  .kpi .big{font-size:18px;font-weight:700;margin-top:8px}
  .country-card{margin-bottom:8px;padding:8px;border-radius:6px;background:#fff;border:1px solid #f0f0f0;font-size:13px}
  .slider-row { margin-bottom: 12px; }
  .ref { font-size:11px;color:#666;margin-top:8px; line-height:1.35;}

.card > label:first-child, 
.card > h3:first-child {
  font-size: 14px;
  font-weight: 600;
  margin-bottom: 6px;
  color: #222;
  border-bottom: 1px solid #eee;
  padding-bottom: 4px;
}
/* Neutral sliders (erosion, cost rate) */
input[type="range"].neutral {
  --fill-color: #bbb;
  background: linear-gradient(to right, var(--fill-color) var(--percent), #eee var(--percent));
}
.india-pop-card {
  background: #fafafa;
  border: 1px solid #eee;
  padding: 6px;
  border-radius: 6px;
  margin-top: 6px;
}
.india-pop-card label {
  font-size: 12px;
  font-weight: 500;
  margin-bottom: 2px;
  display: block;
}
</style>
</head>
<body>
  <div id="controls">
    <h2>Model parameters</h2>
    
    <div class="card">
        <label>Indications</label>
        <div id="indicationChecks" class="checks"></div>
    </div>

    <div class="card">
      <label>Regions</label>
      <div id="countryChecks" class="checks"></div>
    </div>
    
    <div class="card">
        <label>Peak Market Share Year (by Region)</label>
        <div id="peakYearSlidersContainer"></div>
    </div>

    <div class="card">
      <label for="patentExtensionInput">Patent Exclusivity Extension (+ Years)</label>
      <input id="patentExtensionInput" type="number" min="0" max="10" step="1" value="0" />
      <div class="small" style="margin-top:6px">Applies to all selected regions.</div>
      
      <div style="height:10px"></div>
      <label for="erosionRate">Post-LoE annual erosion (%)</label>
      <input id="erosionRate" type="range" min="0.5" max="5" step="0.1" value="2.5" />
      <div class="small">Compounding decline after LoE: <span id="erosionRateVal">2.5%</span>/yr</div>
    </div>

    <div class="card">
  	<label>Treatment cost (USD, by region)</label>
  	<div id="treatmentCostSliders"></div>
	</div>
    
    <div class="card">
        <label>Cost Parameters</label>
        <label for="variableCostSlider" class="small" style="font-weight:normal;margin-bottom:4px;">Operational Cost Rate (% of Gross Revenue)</label>
        <input id="variableCostSlider" type="range" min="1" max="30" step="0.1" value="5" />
        <div class="small">Current rate: <span id="variableCostVal">5.0%</span>/yr</div>
        <div class="small" style="margin-top:8px;">Note: A flat $30M cost for the Phase II trial is applied in 2028.</div>
    </div>

    <div class="card">
      <h3 style="margin:0 0 8px 0">Base assumptions (read-only)</h3>
      <div id="countryAssumptions"></div>

      <!-- New explanatory notes -->
      <div id="assumptionNotes" class="small" style="margin-top:8px; line-height:1.45">
        <div><strong>Patient figures</strong>: For each region, the counts shown per indication (<strong>Glioblastoma</strong>, <strong>Brain Metastasis</strong>, <strong>OPBT</strong>) are the incidence values used by the model (same years window and neurosurgery filters). If data is insufficient in a specific country or region, assumptions are based on other regions' data.</div>
        <div style="margin-top:8px;"><strong>Clinical costs</strong>: A flat <strong>$30M</strong> Phase II cost is applied in <strong>2028</strong>. Each additional indication incurs a <strong>$25M</strong> bridging study cost, applied at <strong>Launch (2030)</strong> for the first add-on, and then at <strong>+3 years</strong> for subsequent add-ons.</div>
        <div style="margin-top:8px;"><strong>Operational cost slider</strong>: Covers <strong>Marketing</strong>, <strong>CMC</strong>, <strong>COGs</strong>, and <strong>FTE</strong> (expressed as % of gross revenue).</div>

        <div style="margin-top:10px"><strong>Sources</strong>:</div>
        <div class="ref">
          https://academic.oup.com/neuro-oncology/article/23/9/1447/6256866<br>
          https://www.ncbi.nlm.nih.gov/books/NBK470246/<br>
          https://www.nature.com/articles/s43856-024-00445-7<br>
          https://www.nejm.org/doi/full/10.1056/NEJM199002223220802<br>
          https://pmc.ncbi.nlm.nih.gov/articles/PMC9533228<br>
          https://statistik.incanet.se/CNS/<br>
          https://www.nature.com/articles/s41598-024-79170-z<br>
          https://www.worldometers.info/world-population/<br>
          https://glioblastomafoundation.org/news/glioblastoma-multiforme<br>
          https://academic.oup.com/nop/article/6/1/37/5001149
        </div>
      </div>
    </div>
  </div>

  <div id="graphWrap">
    <div id="plot">
      <svg id="arrowOverlay" xmlns="http://www.w3.org/2000/svg"></svg>
    </div>

    <div class="kpis">
      <div class="kpi">
        <div class="small">Peak Revenue (USD)</div>
        <div class="big" id="peakSalesVal">$0</div>
        <div class="small" id="peakSalesYear">Year: —</div>
      </div>

      <div class="kpi">
        <div class="small">Cumulative Revenue</div>
        <div style="display:flex;gap:8px;align-items:center;justify-content:center;margin-top:6px">
          <select id="cumStart"></select><div class="small">→</div><select id="cumEnd"></select>
        </div>
        <div class="big" id="cumSalesVal">$0</div>
        <div class="small" id="cumSpan">Span: —</div>
      </div>
    </div>
  </div>

  <script>
  // -------------------------------
  // Model years & anchors
  // -------------------------------
  const years = Array.from({length: 20}, (_, i) => 2028 + i); // 2028..2047
  const launchYear = 2030;
  const launchIdx = Math.max(0, years.indexOf(launchYear));
  const baseTreatmentCosts = {
  "EU4+UK": 70000,
  "US": 70000,
  "Japan": 70000,
  "India": 25000
};

  // -------------------------------
  // Epidemiology data 
  // -------------------------------
  // Flat yearly incidence arrays using the exact numbers you provided
  const allIndicationsData = {
    "Glioblastoma": {
      cases: {
        "EU4+UK": Array(years.length).fill(11298),
        "US":     Array(years.length).fill(10879),
        "Japan":  Array(years.length).fill(1387),
	"India":  Array(years.length).fill(12600)
      },
      neurosurgeryPct: { "EU4+UK": 0.70, "US": 0.73, "Japan": 0.70, "India": 0.50 }
    },
    "Brain Metastasis": {
      cases: {
        "EU4+UK": Array(years.length).fill(45903),
        "US":     Array(years.length).fill(49964),
        "Japan":  Array(years.length).fill(16616),
	"India":  Array(years.length).fill(111300)
      },
      neurosurgeryPct: { "EU4+UK": 0.25, "US": 0.25, "Japan": 0.25, "India": 0.15 }
    },
    "OPBT": {
      cases: {
        "EU4+UK": Array(years.length).fill(2445),
        "US":     Array(years.length).fill(3344),
        "Japan":  Array(years.length).fill(453),
	"India": Array(years.length).fill(2445)
      },
      neurosurgeryPct: { "EU4+UK": 0.33, "US": 0.33, "Japan": 0.33, "India": 0.33 }
    }
  };

  const indicationOrder = ["Glioblastoma", "Brain Metastasis", "OPBT"];
  const groupOrder = ["EU4+UK", "US", "Japan", "India"];
  const groupColors = { "EU4+UK": "#2f6df6", "US": "#00b37e", "Japan": "#f59e0b", "India": "#fc0000" };

  // -------------------------------
  // Parameters & state
  // -------------------------------
  const baseLoeYears = { "EU4+UK": 2040, "US": 2037, "Japan": 2040, "India": 2040 };
  let peakYearsByGroup = { "EU4+UK": 2036, "US": 2036, "Japan": 2036, "India": 2036 };
  let currentTotalNetRevenues = [];
let currentTreatmentCosts = { ...baseTreatmentCosts };
// -------------------------------
// India population scaling (immutable baselines)
// -------------------------------
const INDIA_BASE_POP = 1400000000;
let indiaPopulation = INDIA_BASE_POP; // single source of truth
const baselineIndiaCases = {
  "Glioblastoma": 12600,
  "Brain Metastasis": 111300,
  "OPBT": 2445
};

function setIndiaPopulation(newPop) {
  const val = +newPop || INDIA_BASE_POP;
  indiaPopulation = val;   // <--- this was missing!
  const factor = val / INDIA_BASE_POP;
  Object.keys(baselineIndiaCases).forEach(ind => {
    const base = baselineIndiaCases[ind];
    allIndicationsData[ind].cases['India'] = Array(years.length).fill(Math.round(base * factor));
  });
}

  const additionalDelayYears = 3;   // revenue starts after delay from cost-start
  const additionalRampYears = 4;
  const additionalStartCostValue = 25000000; // $25M per extra indication
  const startupCostValue = 30000000; // $30M Phase II cost applied in 2028

  // Selection order (ensures order of added indications is kept)
  let indicationSelectionOrder = ["Glioblastoma"];

  // -------------------------------
  // DOM refs
  // -------------------------------
  const indicationChecks = document.getElementById('indicationChecks');
  const countryChecks = document.getElementById('countryChecks');
  const countryAssumptions = document.getElementById('countryAssumptions');
  const peakYearSlidersContainer = document.getElementById('peakYearSlidersContainer');
  const patentExtensionInput = document.getElementById('patentExtensionInput');
  const erosionRate = document.getElementById('erosionRate');
  const erosionRateVal = document.getElementById('erosionRateVal');
  const variableCostSlider = document.getElementById('variableCostSlider');
  const variableCostVal = document.getElementById('variableCostVal');
  const peakSalesVal = document.getElementById('peakSalesVal');
  const peakSalesYear = document.getElementById('peakSalesYear');
  const cumStart = document.getElementById('cumStart');
  const cumEnd = document.getElementById('cumEnd');
  const cumSalesVal = document.getElementById('cumSalesVal');
  const cumSpan = document.getElementById('cumSpan');
  const arrowOverlay = document.getElementById('arrowOverlay');
  const plotDiv = document.getElementById('plot');

  // -------------------------------
  // Helpers
  // -------------------------------
  function fmtShortUSD(n) {
    const sign = n < 0 ? "-" : ""; n = Math.abs(n || 0);
    if (n >= 1e9) return `${sign}$${(n / 1e9).toFixed(1).replace(/\.0$/, '')}B`;
    if (n >= 1e6) return `${sign}$${(n / 1e6).toFixed(0)}M`;
    if (n < 1000) return `${sign}$${(n).toFixed(0)}`;
    return `${sign}$${(n / 1e3).toFixed(0)}K`;
  }
  function fmtUSD(n) { return (n === 0) ? '$0' : n.toLocaleString('en-US', {style:'currency', currency:'USD', maximumFractionDigits:0}); }

  // -------------------------------
  // UI utilities
  // -------------------------------
  function createCheckboxes(container, items, defaultCheckedIndices, onChangeCallback) {
    container.innerHTML = '';
    items.forEach((name, index) => {
      const row = document.createElement('label'); row.className = 'check-row';
      const cb = document.createElement('input'); cb.type = 'checkbox';
      cb.checked = defaultCheckedIndices.includes(index);
      cb.value = name;
      if (name === 'Glioblastoma') { cb.checked = true; cb.disabled = true; }
cb.addEventListener('change', (e) => {
  if (container.id === 'indicationChecks') {
    const ind = e.target.value;
    if (e.target.checked) {
      if (!indicationSelectionOrder.includes(ind)) indicationSelectionOrder.push(ind);
    } else {
      indicationSelectionOrder = indicationSelectionOrder.filter(x => x !== ind);
      if (!indicationSelectionOrder.includes('Glioblastoma')) indicationSelectionOrder.unshift('Glioblastoma');
    }
  } else if (container.id === 'countryChecks') {
    // When toggling regions, ensure India input appears
    ensureIndiaCheckboxInput(e.target);

    // If India is just checked, refresh assumptions immediately
    renderCountryAssumptions();

    // If the inline input exists and has a value, keep arrays in sync
    const inline = e.target.parentNode.querySelector('#indiaPopulationInputInline');
    if (inline) setIndiaPopulation(inline.value * 1e6);
  }

  onChangeCallback(e);
});


      const span = document.createElement('span'); span.textContent = name;
      row.appendChild(cb); row.appendChild(span); container.appendChild(row);
    });
  }

  function fillYearSelectors(sel) {
    sel.innerHTML = '';
    years.forEach((y, i) => { const o = document.createElement('option'); o.value = i; o.textContent = y; sel.appendChild(o); });
  }
  function getSelected(containerId) {
    return Array.from(document.querySelectorAll(`#${containerId} input[type=checkbox]`))
                .filter(cb => cb.checked).map(cb => cb.value);
  }
  const getSelectedGroups = () => getSelected('countryChecks');
  const getSelectedIndications = () => getSelected('indicationChecks');

function renderPeakYearSliders() {
  peakYearSlidersContainer.innerHTML = '';
  const selectedGroups = getSelectedGroups();
  selectedGroups.forEach(g => {
    const row = document.createElement('div'); 
    row.className = 'slider-row';

    const label = document.createElement('div'); 
    label.className = 'small';
    label.innerHTML = `<strong style="color:${groupColors[g]}">${g}:</strong> 
                       <span id="peakYearVal-${g}">${peakYearsByGroup[g]}</span>`;

    const slider = document.createElement('input'); 
    slider.type = 'range';
    slider.min = 2034; 
    slider.max = 2040; 
    slider.step = 1;
    slider.dataset.group = g; 
    slider.value = peakYearsByGroup[g];
    slider.style.width = '100%';

    // Gradient fill for region color
    const updateTrack = () => {
      const percent = ((slider.value - slider.min) / (slider.max - slider.min)) * 100;
      slider.style.background = `linear-gradient(to right, ${groupColors[g]} ${percent}%, #e0e0e0 ${percent}%)`;
    };
    updateTrack();
    slider.addEventListener('input', (e) => {
      const group = e.target.dataset.group;
      peakYearsByGroup[group] = parseInt(e.target.value, 10);
      document.getElementById(`peakYearVal-${group}`).textContent = peakYearsByGroup[group];
      updateTrack();
      updatePlot();
    });

    row.appendChild(label); 
    row.appendChild(slider);
    peakYearSlidersContainer.appendChild(row);
  });
}
function ensureIndiaCheckboxInput(cb) {
  // Only for the India checkbox
  if (!cb || cb.value !== 'India') return;

  // Find/remove if unchecked
  let wrapper = cb.parentNode.querySelector('#indiaPopulationInputInlineWrapper');
  if (!cb.checked) {
    if (wrapper) wrapper.remove();
    return;
  }

  // Create once if missing
  if (!wrapper) {
    wrapper = document.createElement('div');
    wrapper.id = 'indiaPopulationInputInlineWrapper';   // <-- so we can find/remove it
    wrapper.className = 'india-pop-card';

    const label = document.createElement('label');
    label.htmlFor = 'indiaPopulationInputInline';
    label.textContent = 'Addressable population (millions)';

    const input = document.createElement('input');
    input.type = 'number';
    input.id = 'indiaPopulationInputInline';
    input.min = '1';
    input.step = '1';
    input.value = 300; // default shown when India is first checked
    input.style.width = '90px';
    input.title = "Enter India's population in millions";

    const onChange = () => {
      const millions = +input.value || 300;
      const fullPop = millions * 1_000_000;
      setIndiaPopulation(fullPop);     // updates indiaPopulation + India case arrays
      renderCountryAssumptions();      // refresh the assumptions panel text
      updatePlot();                    // refresh the chart & KPIs
    };

    input.addEventListener('input', onChange);
    input.addEventListener('change', onChange);

    wrapper.appendChild(label);
    wrapper.appendChild(input);
    cb.parentNode.appendChild(wrapper);

    // Trigger once so the graph updates immediately when India is first checked
    onChange();
  }
}

// -------------------------------
// Treatment cost sliders (NEW)
// -------------------------------
function renderTreatmentCostSliders() {
  const container = document.getElementById('treatmentCostSliders');
  if (!container) return; // defensive
  container.innerHTML = '';
  const selectedGroups = getSelectedGroups();

  // if no group selected, show nothing
  if (!selectedGroups || selectedGroups.length === 0) return;

  selectedGroups.forEach(g => {
    const wrapper = document.createElement('div');
    wrapper.style.marginBottom = '8px';

    const label = document.createElement('div');
    label.className = 'small';
    label.style.color = groupColors[g] || '#111';
    label.innerHTML = `<strong>${g}</strong>: <span id="treatmentCostVal-${g}">${fmtUSD(currentTreatmentCosts[g] || baseTreatmentCosts[g])}</span>`;
    wrapper.appendChild(label);

    const slider = document.createElement('input');
    slider.type = 'range';
    slider.min = 5000;
    slider.max = 150000;
    slider.step = 1000;
    slider.value = currentTreatmentCosts[g] || baseTreatmentCosts[g];
    slider.style.width = '100%';

    // assign thumb color
    try { slider.style.accentColor = groupColors[g]; } catch(e){}

    // update gradient fill
 const updateTrack = () => {
  const percent = ((slider.value - slider.min) / (slider.max - slider.min)) * 100;
  slider.style.setProperty('--percent', percent + '%');
  slider.style.setProperty('--fill-color', groupColors[g]); // region color
};
    updateTrack();
    slider.addEventListener('input', updateTrack);

    // update cost value + replot
    slider.addEventListener('input', (e) => {
      currentTreatmentCosts[g] = +e.target.value;
      const span = document.getElementById(`treatmentCostVal-${g}`);
      if (span) span.textContent = fmtUSD(currentTreatmentCosts[g]);
      updatePlot();
    });

    wrapper.appendChild(slider);
    container.appendChild(wrapper);
  });
}

  // -------------------------------
  // Market share / adoption curves
  // -------------------------------
  function generateMarketShareCurve(peakShareYear, loeYear, erosionFraction, launchYearAnchor = launchYear) {
    const out = new Array(years.length).fill(0);
    const peakIdx = years.indexOf(peakShareYear);
    const loeIdx = years.indexOf(loeYear);
    const launchI = Math.max(0, years.indexOf(launchYearAnchor));
    const effectivePeak = (peakIdx >= launchI) ? peakIdx : launchI;
    const riseSpan = Math.max(0, effectivePeak - launchI);
    const denom = riseSpan + 1;
    for (let i = 0; i < years.length; i++) {
      if (i < launchI) out[i] = 0;
      else if (i <= effectivePeak) {
        const rel = (i - launchI + 1) / denom;
        out[i] = Math.pow(rel, 2);
      } else out[i] = 1.0;
    }
    if (loeIdx !== -1) {
      for (let i = loeIdx + 1; i < years.length; i++) out[i] = Math.pow(1 - erosionFraction, i - loeIdx);
    }
    return out.map(s => Math.max(0, Math.min(1, s)));
  }

  function buildAdditionalIndAdoptionCurvesAndCostYears() {
    const out = { curves: {}, costYears: {} };
    const extras = indicationSelectionOrder.filter(x => x !== 'Glioblastoma');
    extras.forEach((ind, j) => {
      const costStartIdx = launchIdx + 3 * j;
      const revenueStartIdx = costStartIdx + additionalDelayYears;
      const curve = new Array(years.length).fill(0);
      for (let t = 0; t < years.length; t++) {
        if (t < revenueStartIdx) curve[t] = 0;
        else {
          const rampPos = t - revenueStartIdx;
          if (rampPos >= additionalRampYears) curve[t] = 1.0;
          else curve[t] = Math.min(1, (rampPos + 1) / additionalRampYears);
        }
      }
      out.curves[ind] = curve;
      out.costYears[ind] = costStartIdx;
    });
    return out;
  }

  // -------------------------------
  // Arrow overlay rendering (SVG)
  // -------------------------------
  function renderArrowOverlay(timelineEvents) {
    const tickTextElems = plotDiv.querySelectorAll('.xtick text');
    const axisPath = plotDiv.querySelector('.xaxislayer .domain, .xaxislayer-below .domain, .xaxislayer-above .domain');
    if (!tickTextElems || tickTextElems.length === 0 || !axisPath) {
      setTimeout(() => renderArrowOverlay(timelineEvents), 60);
      return;
    }

    const plotBox = plotDiv.getBoundingClientRect();
    arrowOverlay.setAttribute('width', plotBox.width);
    arrowOverlay.setAttribute('height', plotBox.height);
    arrowOverlay.style.width = plotBox.width + 'px';
    arrowOverlay.style.height = plotBox.height + 'px';
    while (arrowOverlay.firstChild) arrowOverlay.removeChild(arrowOverlay.firstChild);

    const tickCenters = {};
    tickTextElems.forEach(el => {
      const t = (el.textContent || '').trim();
      const b = el.getBoundingClientRect();
      const centerX = (b.left + b.right) / 2 - plotBox.left;
      tickCenters[t] = centerX;
    });

    const axisBBox = axisPath.getBoundingClientRect();
    const axisY = axisBBox.top - plotBox.top + axisBBox.height / 2;

    const usedSlots = {};
    timelineEvents.sort((a,b) => (a.year - b.year) || a.label.localeCompare(b.label));
    timelineEvents.forEach((ev, idx) => {
      const tickLabel = `'${String(ev.year).slice(2)}`; // tick text format
      const cx = tickCenters[tickLabel];
      if (typeof cx === 'undefined') return;

      usedSlots[ev.year] = (usedSlots[ev.year] || 0);
      const slotIdx = usedSlots[ev.year];

      const baseShaft = 28;
      const longMultiplier = (idx % 2 === 0) ? 1.9 : 1.0;
      const slotSpacing = 20;
      const shaftLen = Math.round(baseShaft * longMultiplier + slotIdx * slotSpacing);
      const horizDirection = (idx % 2 === 0) ? -1 : 1;
      const horizNudge = horizDirection * Math.min(28, 6 + Math.floor(slotIdx / 2) * 8);

      const ns = "http://www.w3.org/2000/svg";
      const line = document.createElementNS(ns, 'line');
      line.setAttribute('x1', cx + horizNudge);
      line.setAttribute('x2', cx + horizNudge);
      line.setAttribute('y1', axisY + 6);
      line.setAttribute('y2', axisY + 6 + shaftLen - 8);
      line.setAttribute('stroke', ev.color || '#333');
      line.setAttribute('stroke-width', 2);
      line.setAttribute('stroke-linecap', 'round');
      arrowOverlay.appendChild(line);

      const tri = document.createElementNS(ns, 'polygon');
      const tipW = 8;
      const tipH = 8;
      const px = cx + horizNudge;
      const triPoints = `${px - tipW},${axisY + tipH} ${px + tipW},${axisY + tipH} ${px},${axisY}`;
      tri.setAttribute('points', triPoints);
      tri.setAttribute('fill', ev.color || '#333');
      arrowOverlay.appendChild(tri);

      const text = document.createElementNS(ns, 'text');
      text.setAttribute('x', cx + horizNudge);
      text.setAttribute('y', axisY + 6 + shaftLen + 6);
      text.setAttribute('font-size', '11');
      text.setAttribute('fill', ev.color || '#111');
      text.setAttribute('text-anchor', 'middle');
      text.textContent = ev.label;
      arrowOverlay.appendChild(text);

      usedSlots[ev.year] += 1;
    });
  }

// -------------------------------
// Base assumptions rendering (per-region)
// -------------------------------
function renderCountryAssumptions() {
  countryAssumptions.innerHTML = '';
  const selectedGroups = getSelectedGroups();
  const selectedIndications = getSelectedIndications();

  // If nothing selected (edge), default to all regions
  const groupsToShow = (selectedGroups && selectedGroups.length > 0) 
    ? selectedGroups 
    : Object.keys(allIndicationsData.Glioblastoma.cases);

  groupsToShow.forEach(g => {
    const node = document.createElement('div');
    node.className = 'country-card';
    let html = `<strong>${g}</strong>`;

    // Show each indication
    const inds = (selectedIndications && selectedIndications.length > 0) 
      ? selectedIndications 
      : Object.keys(allIndicationsData);

    inds.forEach(indName => {
      const indData = allIndicationsData[indName];
      if (!indData || !indData.cases[g]) return;

      let avgCases;
      if (g === 'India') {
        // India: calculate from population and incidence assumptions
        if (indName === 'Glioblastoma' || indName === 'OPBT') {
          avgCases = Math.round(indiaPopulation * (3 / 100000) * indData.neurosurgeryPct[g]);
        } else if (indName === 'Brain Metastasis') {
          avgCases = Math.round(indiaPopulation * (53.7 / 100000) * indData.neurosurgeryPct[g]);
        }
      } else {
        // Non-India: keep using model cases
        const casesArr = indData.cases[g].slice(0, years.length);
        avgCases = Math.round(casesArr.reduce((a,b) => a + (b||0), 0) / (casesArr.length || 1));
      }

      const neuPct = indData.neurosurgeryPct[g] || 0;
      html += `<div class="small">${indName}: ~${avgCases.toLocaleString()} pts/yr (neurosurg: ${Math.round(neuPct*100)}%)</div>`;
    });

    node.innerHTML = html;
    countryAssumptions.appendChild(node);
  });
}


  // -------------------------------
  // Main plotting logic (unchanged except uses updated data)
  // -------------------------------
  function updatePlot() {
    const selectedGroups = getSelectedGroups();
    const selectedIndications = getSelectedIndications();
    const patentExtension = +patentExtensionInput.value || 0;
    const erosion = +erosionRate.value / 100;

 // region-specific prices (use currentTreatmentCosts if available, else base)
    const pricesByGroup = {};
    const selGroups = getSelectedGroups();
    const priceGroups = (selGroups && selGroups.length > 0) ? selGroups : groupOrder;
    priceGroups.forEach(g => {
      pricesByGroup[g] = (currentTreatmentCosts[g] !== undefined) ? currentTreatmentCosts[g] : baseTreatmentCosts[g];
    });

    const variableCostRate = +variableCostSlider.value / 100;

    const traces = [];
    const totalsGrossRevenueByYear = years.map(() => 0);
    const regionalGrossRevenueByYear = {};
    const regionalPotentialByYear = {};

    const additionalData = buildAdditionalIndAdoptionCurvesAndCostYears();
    const additionalAdoptionCurves = additionalData.curves;

    const groups = (selectedGroups && selectedGroups.length>0) ? selectedGroups : groupOrder;

    groups.forEach(g => {
      const peakShareYear = peakYearsByGroup[g];
      const finalLoeYear = (baseLoeYears[g] || 2040) + patentExtension;
      const shares = generateMarketShareCurve(peakShareYear, finalLoeYear, erosion, launchYear);
      const grossRevenue = years.map(() => 0);
      const potential = years.map(() => 0);

// region-specific price
      const regionPrice = pricesByGroup[g] || baseTreatmentCosts[g];

      const inds = (selectedIndications && selectedIndications.length>0) ? selectedIndications : Object.keys(allIndicationsData);

inds.forEach(ind => {
  const indData = allIndicationsData[ind];
  if (!indData || !indData.cases[g]) return;

  let casesArr;

  if (g === 'India') {
    // --- Dynamically derive cases each year from population & incidence ---
    let incidencePer100k;
    if (ind === 'Glioblastoma' || ind === 'OPBT') {
      incidencePer100k = 3;
    } else if (ind === 'Brain Metastasis') {
      incidencePer100k = 53.7;
    } else {
      incidencePer100k = 0;
    }

    const neuPct = indData.neurosurgeryPct[g] || 0;
    const annualCases = Math.round(indiaPopulation * (incidencePer100k / 100000) * neuPct);

    // Fill the whole array with this value
    casesArr = Array(years.length).fill(annualCases);

    // NOTE: neuPct is already baked into annualCases here
    for (let i = 0; i < years.length; i++) {
      potential[i] += casesArr[i] * regionPrice;
      let adoption = 0;
      if (ind === 'Glioblastoma') adoption = shares[i];
      else adoption = (additionalAdoptionCurves[ind] || new Array(years.length).fill(0))[i] || 0;
      grossRevenue[i] += casesArr[i] * adoption * regionPrice;
    }

  } else {
    // --- Non-India: keep the old logic ---
    casesArr = indData.cases[g].slice(0, years.length);
    for (let i = 0; i < years.length; i++) {
      const cases = casesArr[i] || 0;
      const neuPct = indData.neurosurgeryPct[g] || 0;
      potential[i] += cases * neuPct * regionPrice;
      let adoption = 0;
      if (ind === 'Glioblastoma') adoption = shares[i];
      else adoption = (additionalAdoptionCurves[ind] || new Array(years.length).fill(0))[i] || 0;
      grossRevenue[i] += cases * neuPct * adoption * regionPrice;
    }
  }
});

      regionalGrossRevenueByYear[g] = grossRevenue;
      regionalPotentialByYear[g] = potential;
      grossRevenue.forEach((val,i) => totalsGrossRevenueByYear[i] += val);
    });

    const totalCostsByYear = totalsGrossRevenueByYear.map(gross => gross * variableCostRate);
    totalCostsByYear[0] += startupCostValue;

    const extras = indicationSelectionOrder.filter(x => x !== 'Glioblastoma');
    extras.forEach((ind,k) => {
      const costStartIdx = launchIdx + 3 * k;
      if (costStartIdx >= 0 && costStartIdx < years.length) totalCostsByYear[costStartIdx] += additionalStartCostValue;
    });

    const potentialTotalsByYear = years.map((_, i) => {
      return groups.reduce((s,g) => s + (regionalPotentialByYear[g]?.[i] || 0), 0);
    });

    groups.forEach(g => {
      const regionNetFull = [];
      const regionNetClipped = [];
      const hoverText = [];
      for (let i=0;i<years.length;i++) {
        const grossRegion = regionalGrossRevenueByYear[g][i] || 0;
        const grossTotal = totalsGrossRevenueByYear[i] || 0;
        let costShare = 1 / groups.length;
        if (grossTotal > 0) costShare = grossRegion / grossTotal;
        else {
          const potTotal = potentialTotalsByYear[i];
          if (potTotal > 0) costShare = (regionalPotentialByYear[g]?.[i] || 0) / potTotal;
          else costShare = 1 / groups.length;
        }
        const costForRegion = totalCostsByYear[i] * costShare;
        const netFull = grossRegion - costForRegion;
        regionNetFull.push(netFull);
        regionNetClipped.push(Math.max(0, netFull));
        const revenueToShow = netFull > 0 ? fmtUSD(Math.round(netFull)) : fmtUSD(0);
        hoverText.push(`Revenue: ${revenueToShow}`);
      }

      traces.push({
        x: years, y: regionNetClipped, type: 'bar', name: g, marker: { color: groupColors[g] },
        text: hoverText, hovertemplate: `<b>${g} Revenue</b><br>%{x}<br>%{text}<extra></extra>`, customdata: regionNetFull
      });
    });

    traces.push({
      x: years, y: totalCostsByYear, type: 'scatter', mode: 'lines', name: 'Total Costs',
      line: { color: 'rgba(239, 83, 80, 0.8)', width: 2.5 },
      hovertemplate: `<b>Costs</b><br>%{x}<br>Total Cost: %{y:$,.0f}<extra></extra>`
    });

    const totalsNetRevenueByYear = years.map((_, i) => totalsGrossRevenueByYear[i] - totalCostsByYear[i]);

    const annotations = [];
    totalsNetRevenueByYear.forEach((t,i) => {
      if (t > 1_000_000) annotations.push({ x: years[i], y: t, text: fmtShortUSD(t), xanchor: 'center', yanchor: 'bottom', showarrow: false, font:{size:11,color:'#333'}});
    });

    const dataMin = Math.min(...totalsNetRevenueByYear, ...totalCostsByYear, 0);
    const dataMax = Math.max(...totalsNetRevenueByYear, ...totalCostsByYear, 0);
    const pad = (dataMax - dataMin) * 0.08 || Math.max(Math.abs(dataMax), Math.abs(dataMin)) * 0.08 || 1;
    const yMin = dataMin - pad;
    const yMax = dataMax + pad;
    const xaxisPositionNormalized = (0 - yMin) / (yMax - yMin);

const layout = {
  barmode: 'relative',
  margin: { t: 42, r: 18, l: 70, b: 60 },
  xaxis: { title:'Year', tickmode:'array', tickvals: years, ticktext: years.map(y => `'${String(y).slice(2)}`), automargin:true, position: xaxisPositionNormalized, gridcolor:'#f3f3f3' },
  yaxis: { title:'Revenue / Cost (USD)', automargin:true, autorange:false, range:[yMin,yMax], zeroline:true, zerolinewidth:2, gridcolor:'#f3f3f3' },
  annotations: annotations,
  showlegend: true,
  legend: { x: 0.01, y: 0.98, font:{ size:12 } }
};

    // build timelineEvents first
    const timelineEvents = [
      { year: 2028, label: 'Phase II end', color: '#333' },
      { year: 2030, label: 'Launch', color: '#0b5cff' }
    ];
    const extrasLocal = indicationSelectionOrder.filter(x => x !== 'Glioblastoma');
    extrasLocal.forEach((ind,k) => {
      const costStartIdx = launchIdx + 3 * k;
      const revenueStartIdx = costStartIdx + additionalDelayYears;
      if (costStartIdx >=0 && costStartIdx < years.length) timelineEvents.push({ year: years[costStartIdx], label: `${ind} cost`, color:'#881111' });
      if (revenueStartIdx >=0 && revenueStartIdx < years.length) timelineEvents.push({ year: years[revenueStartIdx], label: `${ind} revenue begins`, color:'#116688' });
    });

    // use newPlot once, then react
    if (!window._plotInitialized) {
      Plotly.newPlot('plot', traces, layout, { responsive:true, displaylogo:false }).then(() => {
        window._plotInitialized = true;
        setTimeout(() => renderArrowOverlay(timelineEvents), 50);
      });
    } else {
      Plotly.react('plot', traces, layout, { responsive:true, displaylogo:false });
      setTimeout(() => renderArrowOverlay(timelineEvents), 50);
    }

    const p = document.getElementById('plot');
    if (p && p.on) {
      p.on('plotly_relayout', () => {
        const timelineEvents = [
          { year: 2028, label: 'Phase II end', color: '#333' },
          { year: 2030, label: 'Launch', color: '#0b5cff' }
        ];
        const extrasLocal = indicationSelectionOrder.filter(x => x !== 'Glioblastoma');
        extrasLocal.forEach((ind,k) => {
          const costStartIdx = launchIdx + 3 * k;
          const revenueStartIdx = costStartIdx + additionalDelayYears;
          if (costStartIdx >=0 && costStartIdx < years.length) timelineEvents.push({ year: years[costStartIdx], label: `${ind} cost`, color:'#881111' });
          if (revenueStartIdx >=0 && revenueStartIdx < years.length) timelineEvents.push({ year: years[revenueStartIdx], label: `${ind} revenue begins`, color:'#116688' });
        });
        renderArrowOverlay(timelineEvents);
      });
    }
    window.addEventListener('resize', () => {
      const timelineEvents = [
        { year: 2028, label: 'Phase II end', color: '#333' },
        { year: 2030, label: 'Launch', color: '#0b5cff' }
      ];
      const extrasLocal = indicationSelectionOrder.filter(x => x !== 'Glioblastoma');
      extrasLocal.forEach((ind,k) => {
        const costStartIdx = launchIdx + 3 * k;
        const revenueStartIdx = costStartIdx + additionalDelayYears;
        if (costStartIdx >=0 && costStartIdx < years.length) timelineEvents.push({ year: years[costStartIdx], label: `${ind} cost`, color:'#881111' });
        if (revenueStartIdx >=0 && revenueStartIdx < years.length) timelineEvents.push({ year: years[revenueStartIdx], label: `${ind} revenue begins`, color:'#116688' });
      });
      setTimeout(() => renderArrowOverlay(timelineEvents), 60);
    });
const maxNetRev = Math.max(...totalsNetRevenueByYear);
const maxRevIndex = totalsNetRevenueByYear.indexOf(maxNetRev);
peakSalesVal.textContent = fmtShortUSD(maxNetRev);
peakSalesYear.textContent = 'Year: ' + years[maxRevIndex];
currentTotalNetRevenues = totalsNetRevenueByYear;
updateCumKPI();

// Color KPI depending on threshold
if (maxNetRev >= 1e9) {
  peakSalesVal.style.color = "#00a65a"; // green if > $1B
} else {
  peakSalesVal.style.color = "#d9534f"; // red otherwise
}

    erosionRateVal.textContent = (+erosionRate.value).toFixed(1) + '%';
    variableCostVal.textContent = (+variableCostSlider.value).toFixed(1) + '%';
    renderCountryAssumptions();
  }

  // -------------------------------
  // Cum KPI
  // -------------------------------
  function updateCumKPI() {
    if (!currentTotalNetRevenues || currentTotalNetRevenues.length === 0) return;
    const si = +cumStart.value; const ei = +cumEnd.value;
    const s = Math.min(si, ei); const e = Math.max(si, ei);
    const sum = currentTotalNetRevenues.slice(s, e + 1).reduce((a, b) => a + b, 0);
    cumSalesVal.textContent = fmtShortUSD(sum);
    cumSpan.textContent = `${years[s]} → ${years[e]} (${e - s + 1} yrs)`;
  }

  // -------------------------------
// Initialization
// -------------------------------
function init() {
  createCheckboxes(indicationChecks, indicationOrder, [0], updatePlot);

  // Keep the same default region selection indices ([0,1,2]) but ensure the handler re-renders
  createCheckboxes(countryChecks, groupOrder, [0,1,2], () => {
    renderPeakYearSliders();
    renderTreatmentCostSliders();
    renderCountryAssumptions();  // <-- force re-render of assumptions when regions change
    updatePlot();
  });

  fillYearSelectors(cumStart);
  fillYearSelectors(cumEnd);
  cumStart.selectedIndex = 0;
  cumEnd.selectedIndex = years.length - 1;

  if (!indicationSelectionOrder.includes('Glioblastoma')) {
    indicationSelectionOrder.unshift('Glioblastoma');
  }

  document.querySelectorAll('#controls input[type=range], #patentExtensionInput')
    .forEach(el => el.addEventListener('input', updatePlot));

  cumStart.addEventListener('change', updateCumKPI);
  cumEnd.addEventListener('change', updateCumKPI);

  renderPeakYearSliders();
  renderTreatmentCostSliders(); // Draw sliders for the initially selected regions
  updatePlot();

  // -------------------------------
  // Neutral slider color setup
  // -------------------------------
  ['erosionRate','variableCostSlider'].forEach(id => {
    const s = document.getElementById(id);
    if (!s) return;

    const updateNeutral = () => {
      const percent = ((s.value - s.min) / (s.max - s.min)) * 100;
      s.style.setProperty('--percent', percent + '%');
      s.style.setProperty('--fill-color', '#888'); // neutral gray
      s.style.background = `linear-gradient(to right, var(--fill-color) ${percent}%, #e0e0e0 ${percent}%)`;
    };

    updateNeutral();
    s.addEventListener('input', updateNeutral);
  });
}

init();
</script>
</body>
</html>

